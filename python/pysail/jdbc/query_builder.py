"""Safe query building with parameterization (no SQL injection)."""

from __future__ import annotations

import re

from pysail.jdbc.exceptions import InvalidOptionsError


def validate_identifier(name: str) -> str:
    """
    Validate SQL identifier to prevent SQL injection.

    Ensures identifier contains only alphanumeric characters, underscores,
    and doesn't start with a digit. This prevents SQL injection through
    column names or table names.

    Args:
        name: Identifier to validate (column name, table name, etc.)

    Returns:
        The validated identifier

    Raises:
        InvalidOptionsError: If identifier contains invalid characters
    """
    if not name:
        message = "Identifier cannot be empty"
        raise InvalidOptionsError(message)

    # Allow alphanumeric, underscore, and period (for schema.table)
    # Must start with letter or underscore
    if not re.match(r"^[a-zA-Z_][a-zA-Z0-9_\.]*$", name):
        message = (
            f"Invalid SQL identifier '{name}'. "
            "Identifiers must start with a letter or underscore and contain only "
            "alphanumeric characters, underscores, or periods."
        )
        raise InvalidOptionsError(message)

    # Reject common SQL keywords that could be abused
    dangerous_keywords = {
        "select",
        "insert",
        "update",
        "delete",
        "drop",
        "alter",
        "create",
        "truncate",
        "exec",
        "execute",
        "union",
        "declare",
    }
    if name.lower() in dangerous_keywords:
        message = f"Identifier '{name}' is a reserved SQL keyword and cannot be used"
        raise InvalidOptionsError(message)

    return name


def build_partition_predicate(
    column: str,
    value_lower: int,
    value_upper: int,
) -> str:
    """
    Generate WHERE clause SAFELY (quoted column, literal values).

    BAD:  f"WHERE {column} >= {value_lower}"  # SQL injection risk
    GOOD: f'WHERE "{column}" >= {value_lower}'  # Quoted identifier

    Args:
        column: Column name for partitioning (validated for SQL injection)
        value_lower: Lower bound (inclusive)
        value_upper: Upper bound (exclusive)

    Returns:
        Safe WHERE clause predicate

    Raises:
        InvalidOptionsError: If column name is invalid
    """
    # Validate column identifier to prevent SQL injection
    validated_col = validate_identifier(column)

    # Quote column identifier (double quotes for most DBs, backticks for MySQL handled by backend)
    quoted_col = f'"{validated_col}"'

    # Values are integers; no injection risk, but use literals
    return f"{quoted_col} >= {value_lower} AND {quoted_col} < {value_upper}"


def build_filtered_query(
    base_query: str,
    predicate: str,
) -> str:
    """
    Wrap base query and append WHERE safely.

    Example:
      Input:  SELECT * FROM orders WHERE status='active'
      Predicate: order_id >= 100 AND order_id < 200
      Output: (SELECT * FROM orders WHERE status='active') AS _sail_part WHERE order_id >= 100 AND order_id < 200

    Args:
        base_query: Base SQL query or table name
        predicate: WHERE clause predicate

    Returns:
        Wrapped query with predicate applied
    """
    # Wrap in subquery to isolate
    return f"({base_query}) AS _sail_part WHERE {predicate}"


def build_query_for_partition(
    dbtable: str | None = None,
    query: str | None = None,
    predicate: str | None = None,
) -> str:
    """
    Build final query for a partition.

    Args:
        dbtable: Table name or subquery (SELECT ...) AS alias
        query: Full SQL query (alternative to dbtable)
        predicate: Optional WHERE clause predicate for this partition

    Returns:
        Complete SQL query for partition
    """
    # Use either dbtable or query as base
    base = query if query else dbtable

    if not base:
        msg = "Either dbtable or query must be provided"
        raise ValueError(msg)

    # If no predicate, return base as-is
    if not predicate:
        if dbtable and not query:
            stripped = dbtable.strip()
            if stripped.startswith("("):
                return f"SELECT * FROM {dbtable}"  # noqa: S608 - subquery with alias provided
            if "SELECT" not in stripped.upper():
                return f"SELECT * FROM {dbtable}"  # noqa: S608 - table option validated
        return base

    # If base is just a table name, wrap it
    if dbtable and not query:
        stripped = dbtable.strip()
        if stripped.startswith("("):
            return f"SELECT * FROM {dbtable} WHERE {predicate}"  # noqa: S608 - predicate generated by planner
        if "SELECT" not in stripped.upper():
            return f"SELECT * FROM {dbtable} WHERE {predicate}"  # noqa: S608 - predicate generated by planner

    # Otherwise wrap in subquery
    return build_filtered_query(base, predicate)


def build_schema_inference_query(
    dbtable: str | None = None,
    query: str | None = None,
) -> str:
    """
    Build LIMIT 1 query for schema inference.

    Args:
        dbtable: Table name or subquery
        query: Full SQL query (alternative to dbtable)

    Returns:
        Query that returns at most 1 row for schema inference
    """
    base = query if query else dbtable

    if not base:
        msg = "Either dbtable or query must be provided"
        raise ValueError(msg)

    # If dbtable is just a table name, add SELECT * FROM
    if dbtable and not query:
        stripped = dbtable.strip()
        if stripped.startswith("("):
            return f"SELECT * FROM {dbtable} LIMIT 1"  # noqa: S608 - subquery with alias provided
        if "SELECT" not in stripped.upper():
            return f"SELECT * FROM {dbtable} LIMIT 1"  # noqa: S608 - identifier validated upstream

    # Otherwise wrap in subquery
    return f"({base}) AS _schema_infer LIMIT 1"


def execute_parametrized_query(cursor, query: str, params: tuple):
    """
    Execute query with parameters (no string formatting).

    For backends that support parameterized queries (ADBC with capability check).

    Args:
        cursor: Database cursor
        query: SQL query with parameter placeholders (?)
        params: Tuple of parameter values

    Example:
        query = "SELECT * FROM orders WHERE user_id = ? AND date > ?"
        params = (123, "2024-01-01")
    """
    cursor.execute(query, params)
