== Codegen ==
Whole-stage codegen is not supported; showing physical plan instead.

== Plan Steps ==
initial_logical_plan:
MergeInto: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_explain_codegen"], format: "DELTA", location: "<tmp>/merge_explain_codegen", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }, Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#8", data_type: Int32, nullable: true }, Field { name: "#9", data_type: Utf8, nullable: true }, Field { name: "#10", data_type: Int32, nullable: true }, Field { name: "#11", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "t" }), name: "#0" }), op: Eq, right: Column(Column { relation: Some(Bare { table: "s" }), name: "#8" }) }), op: And, right: IsNotNull(Column(Column { relation: Some(Bare { table: "t" }), name: "#1" })) }), source: Some("t . id = s . id AND t . category IS NOT NULL ") }, matched_clauses: [MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "t" }), name: "#1" }), op: Eq, right: Literal(Utf8("vip"), None) }), source: Some("t . category = 'vip' ") }), action: UpdateSet([MergeAssignment { column: "#2", value: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "s" }), name: "#10" }), op: Plus, right: Literal(Int32(1), None) }) }, MergeAssignment { column: "#3", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: Some(Bare { table: "s" }), name: "#11" }), Literal(Utf8("_"), None), Column(Column { relation: Some(Bare { table: "t" }), name: "#0" })] }) }]) }, MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "t" }), name: "#1" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: Delete }], not_matched_by_source_clauses: [MergeNotMatchedBySourceClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "t" }), name: "#1" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: UpdateSet([MergeAssignment { column: "#3", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: Some(Bare { table: "t" }), name: "#3" }), Literal(Utf8("_orphan"), None)] }) }]) }], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertColumns { columns: ["#0", "#1", "#2", "#3"], values: [Column(Column { relation: Some(Bare { table: "s" }), name: "#8" }), Column(Column { relation: Some(Bare { table: "s" }), name: "#9" }), Column(Column { relation: Some(Bare { table: "s" }), name: "#10" }), ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Literal(Utf8("insert_"), None), Column(Column { relation: Some(Bare { table: "s" }), name: "#11" })] })] } }], join_key_pairs: [(Column(Column { relation: Some(Bare { table: "t" }), name: "#0" }), Column(Column { relation: Some(Bare { table: "s" }), name: "#8" }))], residual_predicates: [IsNotNull(Column(Column { relation: Some(Bare { table: "t" }), name: "#1" }))], target_only_predicates: [IsNotNull(Column(Column { relation: Some(Bare { table: "t" }), name: "#1" }))] }
  SubqueryAlias: t
    Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3
      TableScan: delta_merge_explain_codegen
  SubqueryAlias: s
    Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
      Filter: src_merge_explain_codegen.#6 + Int32(1) > Int32(10) AND (src_merge_explain_codegen.#4 = Int32(1) OR src_merge_explain_codegen.#4 = Int32(2) OR src_merge_explain_codegen.#4 = Int32(4))
        Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
          Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
            SubqueryAlias: src_merge_explain_codegen
              Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                SubqueryAlias: src
                  Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                    Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                      Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))

logical_plan after resolve_grouping_function:
SAME TEXT AS ABOVE

logical_plan after type_coercion:
SAME TEXT AS ABOVE

analyzed_logical_plan:
SAME TEXT AS ABOVE

logical_plan after expand_merge:
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_explain_codegen"], format: "DELTA", location: "<tmp>/merge_explain_codegen", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }, Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#8", data_type: Int32, nullable: true }, Field { name: "#9", data_type: Utf8, nullable: true }, Field { name: "#10", data_type: Int32, nullable: true }, Field { name: "#11", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "category" })) }), source: Some("t . id = s . id AND t . category IS NOT NULL ") }, matched_clauses: [MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("vip"), None) }), source: Some("t . category = 'vip' ") }), action: UpdateSet([MergeAssignment { column: "amount", value: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "__sail_src_amount" }), op: Plus, right: Literal(Int32(1), None) }) }, MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "__sail_src_note" }), Literal(Utf8("_"), None), Column(Column { relation: None, name: "id" })] }) }]) }, MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: Delete }], not_matched_by_source_clauses: [MergeNotMatchedBySourceClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: UpdateSet([MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "note" }), Literal(Utf8("_orphan"), None)] }) }]) }], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertColumns { columns: ["id", "category", "amount", "note"], values: [Column(Column { relation: None, name: "__sail_src_id" }), Column(Column { relation: None, name: "__sail_src_category" }), Column(Column { relation: None, name: "__sail_src_amount" }), ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Literal(Utf8("insert_"), None), Column(Column { relation: None, name: "__sail_src_note" })] })] } }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))], target_only_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))] }
  Projection: CASE WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_id ELSE id END AS id, CASE WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_category ELSE category END AS category, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") THEN __sail_src_amount + Int32(1) WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_amount ELSE amount END AS amount, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") THEN spark_concat(__sail_src_note, Utf8("_"), id) WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NULL AND category = Utf8("stale") THEN spark_concat(note, Utf8("_orphan")) WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN spark_concat(Utf8("insert_"), __sail_src_note) ELSE note END AS note
    Filter: __sail_merge_target_row_present IS NOT NULL AND NOT __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("stale") OR NOT __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL
      MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
        Full Join: id = __sail_src_id Filter: category IS NOT NULL
          Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
            Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
              Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                SubqueryAlias: t
                  Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                    TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
          Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
            Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
              SubqueryAlias: s
                Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                  Filter: src_merge_explain_codegen.#6 + Int32(1) > Int32(10) AND (src_merge_explain_codegen.#4 = Int32(1) OR src_merge_explain_codegen.#4 = Int32(2) OR src_merge_explain_codegen.#4 = Int32(4))
                    Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                      Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                        SubqueryAlias: src_merge_explain_codegen
                          Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                            SubqueryAlias: src
                              Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                  Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))
  Projection: __sail_file_path AS __sail_file_path
    Aggregate: groupBy=[[__sail_file_path]], aggr=[[]]
      Filter: __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND id = __sail_src_id AND category IS NOT NULL AND category = Utf8("vip") OR __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND id = __sail_src_id AND category IS NOT NULL AND category = Utf8("stale") OR __sail_merge_target_row_present IS NOT NULL AND NOT __sail_merge_source_row_present IS NOT NULL AND category = Utf8("stale")
        MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
          Full Join: id = __sail_src_id Filter: category IS NOT NULL
            Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
              Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                  SubqueryAlias: t
                    Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                      TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
            Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
              Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                SubqueryAlias: s
                  Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                    Filter: src_merge_explain_codegen.#6 + Int32(1) > Int32(10) AND (src_merge_explain_codegen.#4 = Int32(1) OR src_merge_explain_codegen.#4 = Int32(2) OR src_merge_explain_codegen.#4 = Int32(4))
                      Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                        Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                          SubqueryAlias: src_merge_explain_codegen
                            Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                              SubqueryAlias: src
                                Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                  Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                    Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))

logical_plan after eliminate_nested_union:
SAME TEXT AS ABOVE

logical_plan after simplify_expressions:
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_explain_codegen"], format: "DELTA", location: "<tmp>/merge_explain_codegen", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }, Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#8", data_type: Int32, nullable: true }, Field { name: "#9", data_type: Utf8, nullable: true }, Field { name: "#10", data_type: Int32, nullable: true }, Field { name: "#11", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "category" })) }), source: Some("t . id = s . id AND t . category IS NOT NULL ") }, matched_clauses: [MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("vip"), None) }), source: Some("t . category = 'vip' ") }), action: UpdateSet([MergeAssignment { column: "amount", value: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "__sail_src_amount" }), op: Plus, right: Literal(Int32(1), None) }) }, MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "__sail_src_note" }), Literal(Utf8("_"), None), Column(Column { relation: None, name: "id" })] }) }]) }, MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: Delete }], not_matched_by_source_clauses: [MergeNotMatchedBySourceClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: UpdateSet([MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "note" }), Literal(Utf8("_orphan"), None)] }) }]) }], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertColumns { columns: ["id", "category", "amount", "note"], values: [Column(Column { relation: None, name: "__sail_src_id" }), Column(Column { relation: None, name: "__sail_src_category" }), Column(Column { relation: None, name: "__sail_src_amount" }), ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Literal(Utf8("insert_"), None), Column(Column { relation: None, name: "__sail_src_note" })] })] } }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))], target_only_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))] }
  Projection: CASE WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_id ELSE id END AS id, CASE WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_category ELSE category END AS category, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") THEN __sail_src_amount + Int32(1) WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_amount ELSE amount END AS amount, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") THEN spark_concat(__sail_src_note, Utf8("_"), id) WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NULL AND category = Utf8("stale") THEN spark_concat(note, Utf8("_orphan")) WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN spark_concat(Utf8("insert_"), __sail_src_note) ELSE note END AS note
    Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_target_row_present IS NULL OR __sail_merge_source_row_present IS NULL OR category != Utf8("stale")) OR __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL
      MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
        Full Join: id = __sail_src_id Filter: category IS NOT NULL
          Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
            Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
              Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                SubqueryAlias: t
                  Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                    TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
          Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
            Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
              SubqueryAlias: s
                Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                  Filter: src_merge_explain_codegen.#6 + Int32(1) > Int32(10) AND (src_merge_explain_codegen.#4 = Int32(1) OR src_merge_explain_codegen.#4 = Int32(2) OR src_merge_explain_codegen.#4 = Int32(4))
                    Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                      Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                        SubqueryAlias: src_merge_explain_codegen
                          Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                            SubqueryAlias: src
                              Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                  Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))
  Projection: __sail_file_path AS __sail_file_path
    Aggregate: groupBy=[[__sail_file_path]], aggr=[[]]
      Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_source_row_present IS NOT NULL AND id = __sail_src_id AND category IS NOT NULL AND (category = Utf8("vip") OR category = Utf8("stale")) OR __sail_merge_source_row_present IS NULL AND category = Utf8("stale"))
        MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
          Full Join: id = __sail_src_id Filter: category IS NOT NULL
            Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
              Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                  SubqueryAlias: t
                    Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                      TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
            Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
              Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                SubqueryAlias: s
                  Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                    Filter: src_merge_explain_codegen.#6 + Int32(1) > Int32(10) AND (src_merge_explain_codegen.#4 = Int32(1) OR src_merge_explain_codegen.#4 = Int32(2) OR src_merge_explain_codegen.#4 = Int32(4))
                      Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                        Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                          SubqueryAlias: src_merge_explain_codegen
                            Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                              SubqueryAlias: src
                                Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                  Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                    Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))

logical_plan after replace_distinct_aggregate:
SAME TEXT AS ABOVE

logical_plan after eliminate_join:
SAME TEXT AS ABOVE

logical_plan after decorrelate_predicate_subquery:
SAME TEXT AS ABOVE

logical_plan after scalar_subquery_to_join:
SAME TEXT AS ABOVE

logical_plan after decorrelate_lateral_join:
SAME TEXT AS ABOVE

logical_plan after extract_equijoin_predicate:
SAME TEXT AS ABOVE

logical_plan after eliminate_duplicated_expr:
SAME TEXT AS ABOVE

logical_plan after eliminate_filter:
SAME TEXT AS ABOVE

logical_plan after eliminate_cross_join:
SAME TEXT AS ABOVE

logical_plan after eliminate_limit:
SAME TEXT AS ABOVE

logical_plan after propagate_empty_relation:
SAME TEXT AS ABOVE

logical_plan after eliminate_one_union:
SAME TEXT AS ABOVE

logical_plan after filter_null_join_keys:
SAME TEXT AS ABOVE

logical_plan after eliminate_outer_join:
SAME TEXT AS ABOVE

logical_plan after push_down_limit:
SAME TEXT AS ABOVE

logical_plan after push_down_filter:
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_explain_codegen"], format: "DELTA", location: "<tmp>/merge_explain_codegen", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }, Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#8", data_type: Int32, nullable: true }, Field { name: "#9", data_type: Utf8, nullable: true }, Field { name: "#10", data_type: Int32, nullable: true }, Field { name: "#11", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "category" })) }), source: Some("t . id = s . id AND t . category IS NOT NULL ") }, matched_clauses: [MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("vip"), None) }), source: Some("t . category = 'vip' ") }), action: UpdateSet([MergeAssignment { column: "amount", value: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "__sail_src_amount" }), op: Plus, right: Literal(Int32(1), None) }) }, MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "__sail_src_note" }), Literal(Utf8("_"), None), Column(Column { relation: None, name: "id" })] }) }]) }, MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: Delete }], not_matched_by_source_clauses: [MergeNotMatchedBySourceClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: UpdateSet([MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "note" }), Literal(Utf8("_orphan"), None)] }) }]) }], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertColumns { columns: ["id", "category", "amount", "note"], values: [Column(Column { relation: None, name: "__sail_src_id" }), Column(Column { relation: None, name: "__sail_src_category" }), Column(Column { relation: None, name: "__sail_src_amount" }), ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Literal(Utf8("insert_"), None), Column(Column { relation: None, name: "__sail_src_note" })] })] } }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))], target_only_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))] }
  Projection: CASE WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_id ELSE id END AS id, CASE WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_category ELSE category END AS category, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") THEN __sail_src_amount + Int32(1) WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_amount ELSE amount END AS amount, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") THEN spark_concat(__sail_src_note, Utf8("_"), id) WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NULL AND category = Utf8("stale") THEN spark_concat(note, Utf8("_orphan")) WHEN __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL THEN spark_concat(Utf8("insert_"), __sail_src_note) ELSE note END AS note
    Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_target_row_present IS NULL OR __sail_merge_source_row_present IS NULL OR category != Utf8("stale")) OR __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL
      MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
        Full Join: id = __sail_src_id Filter: category IS NOT NULL
          Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
            Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
              Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                SubqueryAlias: t
                  Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                    TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
          Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
            Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
              SubqueryAlias: s
                Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                  Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                    Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                      SubqueryAlias: src_merge_explain_codegen
                        Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                          SubqueryAlias: src
                            Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                              Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                Filter: column3 + Int32(1) > Int32(10) AND (column1 = Int32(1) OR column1 = Int32(2) OR column1 = Int32(4))
                                  Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))
  Projection: __sail_file_path AS __sail_file_path
    Aggregate: groupBy=[[__sail_file_path]], aggr=[[]]
      Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_source_row_present IS NOT NULL AND id = __sail_src_id AND category IS NOT NULL AND (category = Utf8("vip") OR category = Utf8("stale")) OR __sail_merge_source_row_present IS NULL AND category = Utf8("stale"))
        MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
          Full Join: id = __sail_src_id Filter: category IS NOT NULL
            Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
              Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                  SubqueryAlias: t
                    Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                      TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
            Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
              Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                SubqueryAlias: s
                  Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                    Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                      Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                        SubqueryAlias: src_merge_explain_codegen
                          Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                            SubqueryAlias: src
                              Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                  Filter: column3 + Int32(1) > Int32(10) AND (column1 = Int32(1) OR column1 = Int32(2) OR column1 = Int32(4))
                                    Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))

logical_plan after single_distinct_aggregation_to_group_by:
SAME TEXT AS ABOVE

logical_plan after eliminate_group_by_constant:
SAME TEXT AS ABOVE

logical_plan after common_sub_expression_eliminate:
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_explain_codegen"], format: "DELTA", location: "<tmp>/merge_explain_codegen", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }, Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#8", data_type: Int32, nullable: true }, Field { name: "#9", data_type: Utf8, nullable: true }, Field { name: "#10", data_type: Int32, nullable: true }, Field { name: "#11", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "category" })) }), source: Some("t . id = s . id AND t . category IS NOT NULL ") }, matched_clauses: [MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("vip"), None) }), source: Some("t . category = 'vip' ") }), action: UpdateSet([MergeAssignment { column: "amount", value: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "__sail_src_amount" }), op: Plus, right: Literal(Int32(1), None) }) }, MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "__sail_src_note" }), Literal(Utf8("_"), None), Column(Column { relation: None, name: "id" })] }) }]) }, MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: Delete }], not_matched_by_source_clauses: [MergeNotMatchedBySourceClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: UpdateSet([MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "note" }), Literal(Utf8("_orphan"), None)] }) }]) }], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertColumns { columns: ["id", "category", "amount", "note"], values: [Column(Column { relation: None, name: "__sail_src_id" }), Column(Column { relation: None, name: "__sail_src_category" }), Column(Column { relation: None, name: "__sail_src_amount" }), ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Literal(Utf8("insert_"), None), Column(Column { relation: None, name: "__sail_src_note" })] })] } }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))], target_only_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))] }
  Projection: CASE WHEN __common_expr_1 THEN __sail_src_id ELSE id END AS id, CASE WHEN __common_expr_1 THEN __sail_src_category ELSE category END AS category, CASE WHEN __common_expr_2 THEN __sail_src_amount + Int32(1) WHEN __common_expr_1 THEN __sail_src_amount ELSE amount END AS amount, CASE WHEN __common_expr_2 THEN spark_concat(__sail_src_note, Utf8("_"), id) WHEN __common_expr_3 AND __sail_merge_source_row_present IS NULL AND category = Utf8("stale") THEN spark_concat(note, Utf8("_orphan")) WHEN __common_expr_1 THEN spark_concat(Utf8("insert_"), __sail_src_note) ELSE note END AS note
    Projection: __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL AS __common_expr_1, __common_expr_4 AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") AS __common_expr_2, __common_expr_4 AS __common_expr_3, id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, __sail_merge_target_row_present, __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, __sail_merge_source_row_present
      Projection: __sail_merge_target_row_present IS NOT NULL AS __common_expr_4, id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, __sail_merge_target_row_present, __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, __sail_merge_source_row_present
        Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_target_row_present IS NULL OR __sail_merge_source_row_present IS NULL OR category != Utf8("stale")) OR __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL
          MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
            Full Join: id = __sail_src_id Filter: category IS NOT NULL
              Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
                Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                  Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                    SubqueryAlias: t
                      Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                        TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
              Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
                Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                  SubqueryAlias: s
                    Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                      Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                        Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                          SubqueryAlias: src_merge_explain_codegen
                            Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                              SubqueryAlias: src
                                Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                  Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                    Filter: column3 + Int32(1) > Int32(10) AND (column1 = Int32(1) OR column1 = Int32(2) OR column1 = Int32(4))
                                      Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))
  Projection: __sail_file_path AS __sail_file_path
    Aggregate: groupBy=[[__sail_file_path]], aggr=[[]]
      Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_source_row_present IS NOT NULL AND id = __sail_src_id AND category IS NOT NULL AND (category = Utf8("vip") OR category = Utf8("stale")) OR __sail_merge_source_row_present IS NULL AND category = Utf8("stale"))
        MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
          Full Join: id = __sail_src_id Filter: category IS NOT NULL
            Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
              Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                  SubqueryAlias: t
                    Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                      TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
            Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
              Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                SubqueryAlias: s
                  Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                    Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                      Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                        SubqueryAlias: src_merge_explain_codegen
                          Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                            SubqueryAlias: src
                              Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                  Filter: column3 + Int32(1) > Int32(10) AND (column1 = Int32(1) OR column1 = Int32(2) OR column1 = Int32(4))
                                    Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))

logical_plan after optimize_projections:
SAME TEXT AS ABOVE

logical_plan after expand_merge:
SAME TEXT AS ABOVE

logical_plan after eliminate_nested_union:
SAME TEXT AS ABOVE

logical_plan after simplify_expressions:
SAME TEXT AS ABOVE

logical_plan after replace_distinct_aggregate:
SAME TEXT AS ABOVE

logical_plan after eliminate_join:
SAME TEXT AS ABOVE

logical_plan after decorrelate_predicate_subquery:
SAME TEXT AS ABOVE

logical_plan after scalar_subquery_to_join:
SAME TEXT AS ABOVE

logical_plan after decorrelate_lateral_join:
SAME TEXT AS ABOVE

logical_plan after extract_equijoin_predicate:
SAME TEXT AS ABOVE

logical_plan after eliminate_duplicated_expr:
SAME TEXT AS ABOVE

logical_plan after eliminate_filter:
SAME TEXT AS ABOVE

logical_plan after eliminate_cross_join:
SAME TEXT AS ABOVE

logical_plan after eliminate_limit:
SAME TEXT AS ABOVE

logical_plan after propagate_empty_relation:
SAME TEXT AS ABOVE

logical_plan after eliminate_one_union:
SAME TEXT AS ABOVE

logical_plan after filter_null_join_keys:
SAME TEXT AS ABOVE

logical_plan after eliminate_outer_join:
SAME TEXT AS ABOVE

logical_plan after push_down_limit:
SAME TEXT AS ABOVE

logical_plan after push_down_filter:
SAME TEXT AS ABOVE

logical_plan after single_distinct_aggregation_to_group_by:
SAME TEXT AS ABOVE

logical_plan after eliminate_group_by_constant:
SAME TEXT AS ABOVE

logical_plan after common_sub_expression_eliminate:
SAME TEXT AS ABOVE

logical_plan after optimize_projections:
SAME TEXT AS ABOVE

logical_plan:
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_explain_codegen"], format: "DELTA", location: "<tmp>/merge_explain_codegen", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }, Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#8", data_type: Int32, nullable: true }, Field { name: "#9", data_type: Utf8, nullable: true }, Field { name: "#10", data_type: Int32, nullable: true }, Field { name: "#11", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "category" })) }), source: Some("t . id = s . id AND t . category IS NOT NULL ") }, matched_clauses: [MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("vip"), None) }), source: Some("t . category = 'vip' ") }), action: UpdateSet([MergeAssignment { column: "amount", value: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "__sail_src_amount" }), op: Plus, right: Literal(Int32(1), None) }) }, MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "__sail_src_note" }), Literal(Utf8("_"), None), Column(Column { relation: None, name: "id" })] }) }]) }, MergeMatchedClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: Delete }], not_matched_by_source_clauses: [MergeNotMatchedBySourceClause { condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "category" }), op: Eq, right: Literal(Utf8("stale"), None) }), source: Some("t . category = 'stale' ") }), action: UpdateSet([MergeAssignment { column: "note", value: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Column(Column { relation: None, name: "note" }), Literal(Utf8("_orphan"), None)] }) }]) }], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertColumns { columns: ["id", "category", "amount", "note"], values: [Column(Column { relation: None, name: "__sail_src_id" }), Column(Column { relation: None, name: "__sail_src_category" }), Column(Column { relation: None, name: "__sail_src_amount" }), ScalarFunction(ScalarFunction { func: ScalarUDF { inner: SparkConcat { signature: Signature { type_signature: VariadicAny, volatility: Immutable, parameter_names: None } } }, args: [Literal(Utf8("insert_"), None), Column(Column { relation: None, name: "__sail_src_note" })] })] } }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))], target_only_predicates: [IsNotNull(Column(Column { relation: None, name: "category" }))] }
  Projection: CASE WHEN __common_expr_1 THEN __sail_src_id ELSE id END AS id, CASE WHEN __common_expr_1 THEN __sail_src_category ELSE category END AS category, CASE WHEN __common_expr_2 THEN __sail_src_amount + Int32(1) WHEN __common_expr_1 THEN __sail_src_amount ELSE amount END AS amount, CASE WHEN __common_expr_2 THEN spark_concat(__sail_src_note, Utf8("_"), id) WHEN __common_expr_3 AND __sail_merge_source_row_present IS NULL AND category = Utf8("stale") THEN spark_concat(note, Utf8("_orphan")) WHEN __common_expr_1 THEN spark_concat(Utf8("insert_"), __sail_src_note) ELSE note END AS note
    Projection: __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL AS __common_expr_1, __common_expr_4 AND __sail_merge_source_row_present IS NOT NULL AND category = Utf8("vip") AS __common_expr_2, __common_expr_4 AS __common_expr_3, id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, __sail_merge_target_row_present, __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, __sail_merge_source_row_present
      Projection: __sail_merge_target_row_present IS NOT NULL AS __common_expr_4, id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, __sail_merge_target_row_present, __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, __sail_merge_source_row_present
        Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_target_row_present IS NULL OR __sail_merge_source_row_present IS NULL OR category != Utf8("stale")) OR __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL
          MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
            Full Join: id = __sail_src_id Filter: category IS NOT NULL
              Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
                Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                  Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                    SubqueryAlias: t
                      Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                        TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
              Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
                Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                  SubqueryAlias: s
                    Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                      Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                        Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                          SubqueryAlias: src_merge_explain_codegen
                            Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                              SubqueryAlias: src
                                Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                  Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                    Filter: column3 + Int32(1) > Int32(10) AND (column1 = Int32(1) OR column1 = Int32(2) OR column1 = Int32(4))
                                      Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))
  Projection: __sail_file_path AS __sail_file_path
    Aggregate: groupBy=[[__sail_file_path]], aggr=[[]]
      Filter: __sail_merge_target_row_present IS NOT NULL AND (__sail_merge_source_row_present IS NOT NULL AND id = __sail_src_id AND category IS NOT NULL AND (category = Utf8("vip") OR category = Utf8("stale")) OR __sail_merge_source_row_present IS NULL AND category = Utf8("stale"))
        MergeCardinalityCheck: target_row_id_col=__sail_merge_target_row_id, target_present_col=__sail_merge_target_row_present, source_present_col=__sail_merge_source_row_present
          Full Join: id = __sail_src_id Filter: category IS NOT NULL
            Projection: id, category, amount, note, __sail_file_path, __sail_merge_target_row_id, Boolean(true) AS __sail_merge_target_row_present
              Projection: id, category, amount, note, __sail_file_path, uuid() AS __sail_merge_target_row_id
                Projection: t.#0 AS id, t.#1 AS category, t.#2 AS amount, t.#3 AS note, t.__sail_file_path AS __sail_file_path
                  SubqueryAlias: t
                    Projection: delta_merge_explain_codegen.id AS #0, delta_merge_explain_codegen.category AS #1, delta_merge_explain_codegen.amount AS #2, delta_merge_explain_codegen.note AS #3, delta_merge_explain_codegen.__sail_file_path AS __sail_file_path
                      TableScan: delta_merge_explain_codegen projection=[id, category, amount, note, __sail_file_path]
            Projection: __sail_src_id, __sail_src_category, __sail_src_amount, __sail_src_note, Boolean(true) AS __sail_merge_source_row_present
              Projection: s.#8 AS __sail_src_id, s.#9 AS __sail_src_category, s.#10 AS __sail_src_amount, s.#11 AS __sail_src_note
                SubqueryAlias: s
                  Projection: src_merge_explain_codegen.#4 AS #8, src_merge_explain_codegen.#5 AS #9, src_merge_explain_codegen.#6 AS #10, src_merge_explain_codegen.#7 AS #11
                    Projection: src_merge_explain_codegen.id AS #4, src_merge_explain_codegen.category AS #5, src_merge_explain_codegen.amount AS #6, src_merge_explain_codegen.note AS #7
                      Projection: src_merge_explain_codegen.#8 AS id, src_merge_explain_codegen.#9 AS category, src_merge_explain_codegen.#10 AS amount, src_merge_explain_codegen.#11 AS note
                        SubqueryAlias: src_merge_explain_codegen
                          Projection: src.#4 AS #8, src.#5 AS #9, src.#6 AS #10, src.#7 AS #11
                            SubqueryAlias: src
                              Projection: #0 AS #4, #1 AS #5, #2 AS #6, #3 AS #7
                                Projection: column1 AS #0, column2 AS #1, column3 AS #2, column4 AS #3
                                  Filter: column3 + Int32(1) > Int32(10) AND (column1 = Int32(1) OR column1 = Int32(2) OR column1 = Int32(4))
                                    Values: (Int32(1), Utf8("existing"), Int32(15), Utf8("promote")), (Int32(2), Utf8("vip"), Int32(22), Utf8("platinum")), (Int32(4), Utf8("standard"), Int32(25), Utf8("regular"))

initial_physical_plan:
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
  UnionExec
    DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
      ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
        ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
          ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
            FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
              MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL
                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                      ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                        ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                          ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                            DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                    ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                      ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                        ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                          ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                            ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                              ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                  FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                    DataSourceExec: partitions=1, partition_sizes=[<sizes>]
    DeltaRemoveActionsExec
      DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
        ProjectionExec: expr=[__sail_file_path@0 as __sail_file_path]
          AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
            AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
              FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                  HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                        ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                          ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                            ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                              DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
                    ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                      ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                        ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                          ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                            ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                              ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                  ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>]


initial_physical_plan_with_stats:
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
  UnionExec, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
    DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
      ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:)]]
        ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:),(Col[9]:),(Col[10]:),(Col[11]:),(Col[12]:),(Col[13]:),(Col[14]:)]]
          ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:),(Col[9]:),(Col[10]:),(Col[11]:),(Col[12]:)]]
            FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:),(Col[9]:),(Col[10]:),(Col[11]:)]]
              MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:),(Col[9]:),(Col[10]:),(Col[11]:)]]
                HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL, statistics=[Rows=Inexact(3), Bytes=Absent, [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]: Null=Inexact(0)),(Col[8]: Null=Inexact(0)),(Col[9]: Null=Inexact(0)),(Col[10]: Null=Inexact(0)),(Col[11]:)]]
                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:)]]
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:),(Col[5]:)]]
                      ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                        ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                          ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                            DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet, statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0)),(Col[4]:)]]
                    ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                      ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                        ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                          ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                            ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                              ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                  FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4), statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                    DataSourceExec: partitions=1, partition_sizes=[<sizes>], statistics=[Rows=Exact(3), Bytes=Exact(<bytes>), [(Col[0]: Null=Exact(0)),(Col[1]: Null=Exact(0)),(Col[2]: Null=Exact(0)),(Col[3]: Null=Exact(0))]]
    DeltaRemoveActionsExec, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
      DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:)]]
        ProjectionExec: expr=[__sail_file_path@0 as __sail_file_path], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
          AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
            AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
              FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:),(Col[9]:),(Col[10]:),(Col[11]:)]]
                MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:),(Col[9]:),(Col[10]:),(Col[11]:)]]
                  HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL, statistics=[Rows=Inexact(3), Bytes=Absent, [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]: Null=Inexact(0)),(Col[8]: Null=Inexact(0)),(Col[9]: Null=Inexact(0)),(Col[10]: Null=Inexact(0)),(Col[11]:)]]
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:)]]
                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:),(Col[5]:)]]
                        ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                          ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                            ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path], statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                              DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet, statistics=[Rows=Exact(3), Bytes=Inexact(<bytes>), [(Col[0]: Min=Exact(Int32(1)) Max=Exact(Int32(3))),(Col[1]:),(Col[2]: Min=Exact(Int32(10)) Max=Exact(Int32(30))),(Col[3]:),(Col[4]:)]]
                    ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0)),(Col[4]:)]]
                      ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                        ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                          ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                            ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                              ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                  ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3], statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4), statistics=[Rows=Inexact(1), Bytes=Inexact(<bytes>), [(Col[0]: Null=Inexact(0)),(Col[1]: Null=Inexact(0)),(Col[2]: Null=Inexact(0)),(Col[3]: Null=Inexact(0))]]
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>], statistics=[Rows=Exact(3), Bytes=Exact(<bytes>), [(Col[0]: Null=Exact(0)),(Col[1]: Null=Exact(0)),(Col[2]: Null=Exact(0)),(Col[3]: Null=Exact(0))]]


initial_physical_plan_with_schema:
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/), schema=[count:UInt64;N]
  UnionExec, schema=[data:Utf8;N]
    DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/), schema=[data:Utf8;N]
      ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N]
        ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present], schema=[__common_expr_1:Boolean, __common_expr_2:Boolean;N, __common_expr_3:Boolean, id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
          ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present], schema=[__common_expr_4:Boolean, id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
            FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
              MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
                HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean]
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N]
                      ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N]
                        ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path], schema=[#0:Int32;N, #1:Utf8;N, #2:Int32;N, #3:Utf8;N, __sail_file_path:Utf8;N]
                          ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N]
                            DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N]
                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present], schema=[__sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean]
                    ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note], schema=[__sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N]
                      ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], schema=[#8:Int32;N, #9:Utf8;N, #10:Int32;N, #11:Utf8;N]
                        ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7], schema=[#4:Int32;N, #5:Utf8;N, #6:Int32;N, #7:Utf8;N]
                          ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N]
                            ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], schema=[#8:Int32;N, #9:Utf8;N, #10:Int32;N, #11:Utf8;N]
                              ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7], schema=[#4:Int32;N, #5:Utf8;N, #6:Int32;N, #7:Utf8;N]
                                ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3], schema=[#0:Int32;N, #1:Utf8;N, #2:Int32;N, #3:Utf8;N]
                                  FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4), schema=[column1:Int32;N, column2:Utf8;N, column3:Int32;N, column4:Utf8;N]
                                    DataSourceExec: partitions=1, partition_sizes=[<sizes>], schema=[column1:Int32;N, column2:Utf8;N, column3:Int32;N, column4:Utf8;N]
    DeltaRemoveActionsExec, schema=[data:Utf8;N]
      DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0), schema=[add:Utf8;N, partition_scan:Boolean]
        ProjectionExec: expr=[__sail_file_path@0 as __sail_file_path], schema=[__sail_file_path:Utf8;N]
          AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[], schema=[__sail_file_path:Utf8;N]
            AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[], schema=[__sail_file_path:Utf8;N]
              FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale), schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
                MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
                  HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean;N, __sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean;N]
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N, __sail_merge_target_row_present:Boolean]
                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N, __sail_merge_target_row_id:Utf8;N]
                        ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N]
                          ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path], schema=[#0:Int32;N, #1:Utf8;N, #2:Int32;N, #3:Utf8;N, __sail_file_path:Utf8;N]
                            ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N]
                              DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet, schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N, __sail_file_path:Utf8;N]
                    ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present], schema=[__sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N, __sail_merge_source_row_present:Boolean]
                      ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note], schema=[__sail_src_id:Int32;N, __sail_src_category:Utf8;N, __sail_src_amount:Int32;N, __sail_src_note:Utf8;N]
                        ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], schema=[#8:Int32;N, #9:Utf8;N, #10:Int32;N, #11:Utf8;N]
                          ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7], schema=[#4:Int32;N, #5:Utf8;N, #6:Int32;N, #7:Utf8;N]
                            ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note], schema=[id:Int32;N, category:Utf8;N, amount:Int32;N, note:Utf8;N]
                              ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11], schema=[#8:Int32;N, #9:Utf8;N, #10:Int32;N, #11:Utf8;N]
                                ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7], schema=[#4:Int32;N, #5:Utf8;N, #6:Int32;N, #7:Utf8;N]
                                  ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3], schema=[#0:Int32;N, #1:Utf8;N, #2:Int32;N, #3:Utf8;N]
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4), schema=[column1:Int32;N, column2:Utf8;N, column3:Int32;N, column4:Utf8;N]
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>], schema=[column1:Int32;N, column2:Utf8;N, column3:Int32;N, column4:Utf8;N]


physical_plan after OutputRequirements:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
        ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
          ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
            ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
              FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                  HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL
                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                        ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                          ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                            ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                              DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
                    ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                      ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                        ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                          ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                            ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                              ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                  ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>]
      DeltaRemoveActionsExec
        DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
          ProjectionExec: expr=[__sail_file_path@0 as __sail_file_path]
            AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
              AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                  MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                    HashJoinExec: mode=Auto, join_type=Full, on=[(id@0, __sail_src_id@0)], filter=category@0 IS NOT NULL
                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                        ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                          ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                            ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
                      ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                        ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                          ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                            ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                              ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                                ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                  ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                    ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                      FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                        DataSourceExec: partitions=1, partition_sizes=[<sizes>]


physical_plan after aggregate_statistics:
SAME TEXT AS ABOVE

physical_plan after join_selection:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
        ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
          ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
            ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
              FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                  ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                    HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                      ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                        ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                          ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                            ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                              ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                                ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                  ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                    ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                      FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                        DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                        ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                          ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                            ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
      DeltaRemoveActionsExec
        DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
          ProjectionExec: expr=[__sail_file_path@0 as __sail_file_path]
            AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
              AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                  MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                    ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                      HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                        ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                          ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                            ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                              ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                                ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                                  ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                    ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                      ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                        FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                          DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                        ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                          ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                            ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                              ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                  DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


physical_plan after LimitedDistinctAggregation:
SAME TEXT AS ABOVE

physical_plan after FilterPushdown:
SAME TEXT AS ABOVE

physical_plan after EnforceDistribution:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
    CoalescePartitionsExec
      UnionExec
        DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
          CoalescePartitionsExec
            ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
              ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
                ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                  FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                    RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                      MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                        ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                          HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                            ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                              ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                                ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                  ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                                    ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                                      ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                        ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                          ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                            FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                              DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                            ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                                  ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                      DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
        DeltaRemoveActionsExec
          DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
            CoalescePartitionsExec
              ProjectionExec: expr=[__sail_file_path@0 as __sail_file_path]
                AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                  RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                    AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                      FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                        RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                          MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                            ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                              HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                  ProjectionExec: expr=[#8@0 as __sail_src_id, #9@1 as __sail_src_category, #10@2 as __sail_src_amount, #11@3 as __sail_src_note]
                                    ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                      ProjectionExec: expr=[id@0 as #4, category@1 as #5, amount@2 as #6, note@3 as #7]
                                        ProjectionExec: expr=[#8@0 as id, #9@1 as category, #10@2 as amount, #11@3 as note]
                                          ProjectionExec: expr=[#4@0 as #8, #5@1 as #9, #6@2 as #10, #7@3 as #11]
                                            ProjectionExec: expr=[#0@0 as #4, #1@1 as #5, #2@2 as #6, #3@3 as #7]
                                              ProjectionExec: expr=[column1@0 as #0, column2@1 as #1, column3@2 as #2, column4@3 as #3]
                                                FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                                  DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                    ProjectionExec: expr=[#0@0 as id, #1@1 as category, #2@2 as amount, #3@3 as note, __sail_file_path@4 as __sail_file_path]
                                      ProjectionExec: expr=[id@0 as #0, category@1 as #1, amount@2 as #2, note@3 as #3, __sail_file_path@4 as __sail_file_path]
                                        ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                          DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


physical_plan after CombinePartialFinalAggregate:
SAME TEXT AS ABOVE

physical_plan after EnforceSorting:
SAME TEXT AS ABOVE

physical_plan after OptimizeAggregateOrder:
SAME TEXT AS ABOVE

physical_plan after ProjectionPushdown:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
    CoalescePartitionsExec
      UnionExec
        DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
          CoalescePartitionsExec
            ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
              ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
                ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                  FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                    RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                      MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                        ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                          HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                            ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                              ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                  DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                            ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                  DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
        DeltaRemoveActionsExec
          DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
            CoalescePartitionsExec
              AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                  AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                    FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                      RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                        MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                          ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                            HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                              ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                  FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                    DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                    DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


physical_plan after coalesce_batches:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
    CoalescePartitionsExec
      UnionExec
        DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
          CoalescePartitionsExec
            ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
              ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
                ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                  CoalesceBatchesExec: target_batch_size=8192
                    FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                      RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                        MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                          ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                            CoalesceBatchesExec: target_batch_size=8192
                              HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                  ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                    CoalesceBatchesExec: target_batch_size=8192
                                      FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                        DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                      DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
        DeltaRemoveActionsExec
          DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
            CoalescePartitionsExec
              AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                CoalesceBatchesExec: target_batch_size=8192
                  RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                    AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                      CoalesceBatchesExec: target_batch_size=8192
                        FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                          RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                            MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                              ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                                CoalesceBatchesExec: target_batch_size=8192
                                  HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                    ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                      ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                        CoalesceBatchesExec: target_batch_size=8192
                                          FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                            DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                        ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                          DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


physical_plan after coalesce_async_exec_input:
SAME TEXT AS ABOVE

physical_plan after OutputRequirements:
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
        CoalescePartitionsExec
          ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
            ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
              ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                CoalesceBatchesExec: target_batch_size=8192
                  FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                    RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                      MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                        ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                          CoalesceBatchesExec: target_batch_size=8192
                            HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                              ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                  CoalesceBatchesExec: target_batch_size=8192
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                    DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
      DeltaRemoveActionsExec
        DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
          CoalescePartitionsExec
            AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
              CoalesceBatchesExec: target_batch_size=8192
                RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                  AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                    CoalesceBatchesExec: target_batch_size=8192
                      FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                        RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                          MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                            ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                              CoalesceBatchesExec: target_batch_size=8192
                                HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                    ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                      CoalesceBatchesExec: target_batch_size=8192
                                        FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                          DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                      ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path]
                                        DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


physical_plan after LimitAggregation:
SAME TEXT AS ABOVE

physical_plan after LimitPushPastWindows:
SAME TEXT AS ABOVE

physical_plan after LimitPushdown:
SAME TEXT AS ABOVE

physical_plan after ProjectionPushdown:
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
        CoalescePartitionsExec
          ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
            ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
              ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                CoalesceBatchesExec: target_batch_size=8192
                  FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                    RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                      MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                        ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                          CoalesceBatchesExec: target_batch_size=8192
                            HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                              ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                  CoalesceBatchesExec: target_batch_size=8192
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                  DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
      DeltaRemoveActionsExec
        DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
          CoalescePartitionsExec
            AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
              CoalesceBatchesExec: target_batch_size=8192
                RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                  AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                    CoalesceBatchesExec: target_batch_size=8192
                      FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                        RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                          MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                            ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                              CoalesceBatchesExec: target_batch_size=8192
                                HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                    ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                      CoalesceBatchesExec: target_batch_size=8192
                                        FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                          DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                      DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


physical_plan after EnsureCooperative:
SAME TEXT AS ABOVE

physical_plan after FilterPushdown(Post):
SAME TEXT AS ABOVE

physical_plan after RewriteExplicitRepartition:
SAME TEXT AS ABOVE

physical_plan after SanityCheckPlan:
SAME TEXT AS ABOVE

physical_plan:
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
        CoalescePartitionsExec
          ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
            ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
              ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                CoalesceBatchesExec: target_batch_size=8192
                  FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                    RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                      MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                        ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                          CoalesceBatchesExec: target_batch_size=8192
                            HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                              ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                  CoalesceBatchesExec: target_batch_size=8192
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                  DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
      DeltaRemoveActionsExec
        DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
          CoalescePartitionsExec
            AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
              CoalesceBatchesExec: target_batch_size=8192
                RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                  AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                    CoalesceBatchesExec: target_batch_size=8192
                      FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                        RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                          MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                            ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                              CoalesceBatchesExec: target_batch_size=8192
                                HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                    ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                      CoalesceBatchesExec: target_batch_size=8192
                                        FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                          DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                      DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet


== Physical Plan ==
DeltaCommitExec(table_path=file://<tmp>/merge_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_explain_codegen/)
        CoalescePartitionsExec
          ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@10 ELSE id@3 END as id, CASE WHEN __common_expr_1@0 THEN __sail_src_category@11 ELSE category@4 END as category, CASE WHEN __common_expr_2@1 THEN __sail_src_amount@12 + 1 WHEN __common_expr_1@0 THEN __sail_src_amount@12 ELSE amount@5 END as amount, CASE WHEN __common_expr_2@1 THEN spark_concat(__sail_src_note@13, _, id@3) WHEN __common_expr_3@2 AND __sail_merge_source_row_present@14 IS NULL AND category@4 = stale THEN spark_concat(note@6, _orphan) WHEN __common_expr_1@0 THEN spark_concat(insert_, __sail_src_note@13) ELSE note@6 END as note]
            ProjectionExec: expr=[__sail_merge_target_row_present@7 IS NULL AND __sail_merge_source_row_present@12 IS NOT NULL as __common_expr_1, __common_expr_4@0 AND __sail_merge_source_row_present@12 IS NOT NULL AND category@2 = vip as __common_expr_2, __common_expr_4@0 as __common_expr_3, id@1 as id, category@2 as category, amount@3 as amount, note@4 as note, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@8 as __sail_src_id, __sail_src_category@9 as __sail_src_category, __sail_src_amount@10 as __sail_src_amount, __sail_src_note@11 as __sail_src_note, __sail_merge_source_row_present@12 as __sail_merge_source_row_present]
              ProjectionExec: expr=[__sail_merge_target_row_present@6 IS NOT NULL as __common_expr_4, id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, __sail_merge_target_row_present@6 as __sail_merge_target_row_present, __sail_src_id@7 as __sail_src_id, __sail_src_category@8 as __sail_src_category, __sail_src_amount@9 as __sail_src_amount, __sail_src_note@10 as __sail_src_note, __sail_merge_source_row_present@11 as __sail_merge_source_row_present]
                CoalesceBatchesExec: target_batch_size=8192
                  FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_target_row_present@6 IS NULL OR __sail_merge_source_row_present@11 IS NULL OR category@1 != stale) OR __sail_merge_target_row_present@6 IS NULL AND __sail_merge_source_row_present@11 IS NOT NULL
                    RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                      MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                        ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                          CoalesceBatchesExec: target_batch_size=8192
                            HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                              ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                  CoalesceBatchesExec: target_batch_size=8192
                                    FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                      DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                              ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                  DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet
      DeltaRemoveActionsExec
        DeltaFileLookupExec(table_url=file:<tmp>/merge_explain_codegen/, version=0)
          CoalescePartitionsExec
            AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
              CoalesceBatchesExec: target_batch_size=8192
                RepartitionExec: partitioning=Hash([__sail_file_path@0], <partitions>), input_partitions=<partitions>
                  AggregateExec: mode=Partial, gby=[__sail_file_path@4 as __sail_file_path], aggr=[]
                    CoalesceBatchesExec: target_batch_size=8192
                      FilterExec: __sail_merge_target_row_present@6 IS NOT NULL AND (__sail_merge_source_row_present@11 IS NOT NULL AND id@0 = __sail_src_id@7 AND category@1 IS NOT NULL AND (category@1 = vip OR category@1 = stale) OR __sail_merge_source_row_present@11 IS NULL AND category@1 = stale)
                        RepartitionExec: partitioning=RoundRobinBatch(<partitions>), input_partitions=<partitions>
                          MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                            ProjectionExec: expr=[id@5 as id, category@6 as category, amount@7 as amount, note@8 as note, __sail_file_path@9 as __sail_file_path, __sail_merge_target_row_id@10 as __sail_merge_target_row_id, __sail_merge_target_row_present@11 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, __sail_merge_source_row_present@4 as __sail_merge_source_row_present]
                              CoalesceBatchesExec: target_batch_size=8192
                                HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)], filter=category@0 IS NOT NULL
                                  ProjectionExec: expr=[__sail_src_id@0 as __sail_src_id, __sail_src_category@1 as __sail_src_category, __sail_src_amount@2 as __sail_src_amount, __sail_src_note@3 as __sail_src_note, true as __sail_merge_source_row_present]
                                    ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_category, column3@2 as __sail_src_amount, column4@3 as __sail_src_note]
                                      CoalesceBatchesExec: target_batch_size=8192
                                        FilterExec: column3@2 + 1 > 10 AND (column1@0 = 1 OR column1@0 = 2 OR column1@0 = 4)
                                          DataSourceExec: partitions=1, partition_sizes=[<sizes>]
                                  ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, __sail_merge_target_row_id@5 as __sail_merge_target_row_id, true as __sail_merge_target_row_present]
                                    ProjectionExec: expr=[id@0 as id, category@1 as category, amount@2 as amount, note@3 as note, __sail_file_path@4 as __sail_file_path, uuid() as __sail_merge_target_row_id]
                                      DataSourceExec: file_groups={1 group: [[<tmp>/merge_explain_codegen/part-<id>.snappy.parquet]]}, projection=[id, category, amount, note, __sail_file_path], file_type=parquet