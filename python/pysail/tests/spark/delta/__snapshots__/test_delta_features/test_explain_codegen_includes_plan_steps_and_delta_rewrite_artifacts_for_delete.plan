== Codegen ==
Whole-stage codegen is not supported; showing physical plan instead.

== Plan Steps ==
initial_logical_plan:
FileDelete: options=FileDeleteOptions { table_name: ["delta_delete_explain_codegen"], path: "<tmp>/delete_explain_codegen", format: "DELTA", condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "salary" }), op: Plus, right: Literal(Int32(1), None) }), op: Gt, right: Literal(Int32(70000), None) }), op: And, right: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "department" }), op: Eq, right: Literal(Utf8("Engineering"), None) }), op: Or, right: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "department" }), op: Eq, right: Literal(Utf8("Marketing"), None) }) }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "active" })) }), source: Some("salary + 1 > 70000 AND ( department = 'Engineering' OR department = 'Marketing' ) AND active IS NOT NULL ") }), options: [] }

logical_plan after resolve_grouping_function:
SAME TEXT AS ABOVE

logical_plan after type_coercion:
SAME TEXT AS ABOVE

analyzed_logical_plan:
SAME TEXT AS ABOVE

logical_plan after expand_merge:
SAME TEXT AS ABOVE

logical_plan after optimize_unions:
SAME TEXT AS ABOVE

logical_plan after simplify_expressions:
SAME TEXT AS ABOVE

logical_plan after replace_distinct_aggregate:
SAME TEXT AS ABOVE

logical_plan after eliminate_join:
SAME TEXT AS ABOVE

logical_plan after decorrelate_predicate_subquery:
SAME TEXT AS ABOVE

logical_plan after scalar_subquery_to_join:
SAME TEXT AS ABOVE

logical_plan after decorrelate_lateral_join:
SAME TEXT AS ABOVE

logical_plan after extract_equijoin_predicate:
SAME TEXT AS ABOVE

logical_plan after eliminate_duplicated_expr:
SAME TEXT AS ABOVE

logical_plan after eliminate_filter:
SAME TEXT AS ABOVE

logical_plan after eliminate_cross_join:
SAME TEXT AS ABOVE

logical_plan after eliminate_limit:
SAME TEXT AS ABOVE

logical_plan after propagate_empty_relation:
SAME TEXT AS ABOVE

logical_plan after filter_null_join_keys:
SAME TEXT AS ABOVE

logical_plan after eliminate_outer_join:
SAME TEXT AS ABOVE

logical_plan after push_down_limit:
SAME TEXT AS ABOVE

logical_plan after push_down_filter:
SAME TEXT AS ABOVE

logical_plan after single_distinct_aggregation_to_group_by:
SAME TEXT AS ABOVE

logical_plan after eliminate_group_by_constant:
SAME TEXT AS ABOVE

logical_plan after common_sub_expression_eliminate:
SAME TEXT AS ABOVE

logical_plan after optimize_projections:
SAME TEXT AS ABOVE

logical_plan:
FileDelete: options=FileDeleteOptions { table_name: ["delta_delete_explain_codegen"], path: "<tmp>/delete_explain_codegen", format: "DELTA", condition: Some(ExprWithSource { expr: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "salary" }), op: Plus, right: Literal(Int32(1), None) }), op: Gt, right: Literal(Int32(70000), None) }), op: And, right: BinaryExpr(BinaryExpr { left: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "department" }), op: Eq, right: Literal(Utf8("Engineering"), None) }), op: Or, right: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "department" }), op: Eq, right: Literal(Utf8("Marketing"), None) }) }) }), op: And, right: IsNotNull(Column(Column { relation: None, name: "active" })) }), source: Some("salary + 1 > 70000 AND ( department = 'Engineering' OR department = 'Marketing' ) AND active IS NOT NULL ") }), options: [] }

initial_physical_plan:
DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
        FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
          DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
            RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4
              DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
                DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                  SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                    RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1
                      ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
      DeltaRemoveActionsExec
        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4
          DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
              SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1
                  ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                    DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet


initial_physical_plan_with_stats:
DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
  CoalescePartitionsExec, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
    UnionExec, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
      DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
        FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:)]]
          DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:)]]
            RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:)]]
              DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:)]]
                DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:)]]
                  SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:)]]
                    RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:)]]
                      ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:)]]
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:)]]
      DeltaRemoveActionsExec, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:)]]
        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:)]]
          DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:)]]
            DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0), statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:)]]
              SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:)]]
                RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:)]]
                  ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version], statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:),(Col[3]:),(Col[4]:),(Col[5]:),(Col[6]:),(Col[7]:),(Col[8]:)]]
                    DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet, statistics=[Rows=Absent, Bytes=Absent, [(Col[0]:),(Col[1]:),(Col[2]:)]]


initial_physical_plan_with_schema:
DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/), schema=[count:UInt64;N]
  CoalescePartitionsExec, schema=[action:Union([(0, Field { name: "add", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64 }, Field { name: "modification_time", data_type: Int64 }, Field { name: "data_change", data_type: Boolean }, Field { name: "stats_json", data_type: Utf8, nullable: true }]) }), (1, Field { name: "remove", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "data_change", data_type: Boolean }, Field { name: "deletion_timestamp", data_type: Int64, nullable: true }, Field { name: "extended_file_metadata", data_type: Boolean, nullable: true }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64, nullable: true }]) }), (2, Field { name: "protocol", data_type: Utf8 }), (3, Field { name: "metadata", data_type: Utf8 }), (4, Field { name: "commit_meta", data_type: Struct([Field { name: "commit_row_count", data_type: UInt64 }, Field { name: "operation_json", data_type: Utf8, nullable: true }, Field { name: "operation_metrics_json", data_type: Utf8 }]) })], Dense)]
    UnionExec, schema=[action:Union([(0, Field { name: "add", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64 }, Field { name: "modification_time", data_type: Int64 }, Field { name: "data_change", data_type: Boolean }, Field { name: "stats_json", data_type: Utf8, nullable: true }]) }), (1, Field { name: "remove", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "data_change", data_type: Boolean }, Field { name: "deletion_timestamp", data_type: Int64, nullable: true }, Field { name: "extended_file_metadata", data_type: Boolean, nullable: true }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64, nullable: true }]) }), (2, Field { name: "protocol", data_type: Utf8 }), (3, Field { name: "metadata", data_type: Utf8 }), (4, Field { name: "commit_meta", data_type: Struct([Field { name: "commit_row_count", data_type: UInt64 }, Field { name: "operation_json", data_type: Utf8, nullable: true }, Field { name: "operation_metrics_json", data_type: Utf8 }]) })], Dense)]
      DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/), schema=[action:Union([(0, Field { name: "add", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64 }, Field { name: "modification_time", data_type: Int64 }, Field { name: "data_change", data_type: Boolean }, Field { name: "stats_json", data_type: Utf8, nullable: true }]) }), (1, Field { name: "remove", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "data_change", data_type: Boolean }, Field { name: "deletion_timestamp", data_type: Int64, nullable: true }, Field { name: "extended_file_metadata", data_type: Boolean, nullable: true }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64, nullable: true }]) }), (2, Field { name: "protocol", data_type: Utf8 }), (3, Field { name: "metadata", data_type: Utf8 }), (4, Field { name: "commit_meta", data_type: Struct([Field { name: "commit_row_count", data_type: UInt64 }, Field { name: "operation_json", data_type: Utf8, nullable: true }, Field { name: "operation_metrics_json", data_type: Utf8 }]) })], Dense)]
        FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL, schema=[id:Int32;N, name:Utf8;N, age:Int32;N, department:Utf8;N, salary:Int32;N, active:Boolean;N]
          DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/), schema=[id:Int32;N, name:Utf8;N, age:Int32;N, department:Utf8;N, salary:Int32;N, active:Boolean;N]
            RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4, schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, partition_scan:Boolean]
              DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/), schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, partition_scan:Boolean]
                DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0), schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N]
                  SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true], schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, __sail_delta_replay_path:Utf8;N, __sail_delta_is_remove:Boolean, __sail_delta_log_version:Int64]
                    RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1, schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, __sail_delta_replay_path:Utf8;N, __sail_delta_is_remove:Boolean, __sail_delta_log_version:Int64]
                      ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version], schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, __sail_delta_replay_path:Utf8;N, __sail_delta_is_remove:Boolean, __sail_delta_log_version:Int64]
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet, schema=[add:Struct([Field { name: "path", data_type: Utf8 }, Field { name: "partitionValues", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64 }, Field { name: "modificationTime", data_type: Int64 }, Field { name: "dataChange", data_type: Boolean }, Field { name: "stats", data_type: Utf8, nullable: true }, Field { name: "tags", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8, nullable: true }]) }, false), nullable: true }, Field { name: "deletionVector", data_type: Struct([Field { name: "storageType", data_type: Utf8 }, Field { name: "pathOrInlineDv", data_type: Utf8 }, Field { name: "offset", data_type: Int32, nullable: true }, Field { name: "sizeInBytes", data_type: Int32 }, Field { name: "cardinality", data_type: Int64 }]), nullable: true }, Field { name: "baseRowId", data_type: Int64, nullable: true }, Field { name: "defaultRowCommitVersion", data_type: Int64, nullable: true }, Field { name: "clusteringProvider", data_type: Utf8, nullable: true }]);N, remove:Struct([Field { name: "path", data_type: Utf8 }, Field { name: "deletionTimestamp", data_type: Int64, nullable: true }, Field { name: "dataChange", data_type: Boolean }, Field { name: "extendedFileMetadata", data_type: Boolean, nullable: true }, Field { name: "partitionValues", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8 }]) }, false), nullable: true }, Field { name: "size", data_type: Int64, nullable: true }, Field { name: "stats", data_type: Utf8, nullable: true }, Field { name: "tags", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8 }]) }, false), nullable: true }, Field { name: "deletionVector", data_type: Struct([Field { name: "storageType", data_type: Utf8 }, Field { name: "pathOrInlineDv", data_type: Utf8 }, Field { name: "offset", data_type: Int32, nullable: true }, Field { name: "sizeInBytes", data_type: Int32 }, Field { name: "cardinality", data_type: Int64 }]), nullable: true }, Field { name: "baseRowId", data_type: Int64, nullable: true }, Field { name: "defaultRowCommitVersion", data_type: Int64, nullable: true }]);N, __sail_delta_log_version:Int64]
      DeltaRemoveActionsExec, schema=[action:Union([(0, Field { name: "add", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64 }, Field { name: "modification_time", data_type: Int64 }, Field { name: "data_change", data_type: Boolean }, Field { name: "stats_json", data_type: Utf8, nullable: true }]) }), (1, Field { name: "remove", data_type: Struct([Field { name: "path", data_type: Utf8 }, Field { name: "data_change", data_type: Boolean }, Field { name: "deletion_timestamp", data_type: Int64, nullable: true }, Field { name: "extended_file_metadata", data_type: Boolean, nullable: true }, Field { name: "partition_values", data_type: Map(Field { name: "entries", data_type: Struct([Field { name: "keys", data_type: Utf8 }, Field { name: "values", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64, nullable: true }]) }), (2, Field { name: "protocol", data_type: Utf8 }), (3, Field { name: "metadata", data_type: Utf8 }), (4, Field { name: "commit_meta", data_type: Struct([Field { name: "commit_row_count", data_type: UInt64 }, Field { name: "operation_json", data_type: Utf8, nullable: true }, Field { name: "operation_metrics_json", data_type: Utf8 }]) })], Dense)]
        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4, schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, partition_scan:Boolean]
          DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/), schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, partition_scan:Boolean]
            DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0), schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N]
              SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true], schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, __sail_delta_replay_path:Utf8;N, __sail_delta_is_remove:Boolean, __sail_delta_log_version:Int64]
                RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1, schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, __sail_delta_replay_path:Utf8;N, __sail_delta_is_remove:Boolean, __sail_delta_log_version:Int64]
                  ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version], schema=[__sail_file_path:Utf8;N, size_bytes:Int64, modification_time:Int64, _commit_version:Int64, _commit_timestamp:Int64, stats_json:Utf8;N, __sail_delta_replay_path:Utf8;N, __sail_delta_is_remove:Boolean, __sail_delta_log_version:Int64]
                    DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet, schema=[add:Struct([Field { name: "path", data_type: Utf8 }, Field { name: "partitionValues", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8, nullable: true }]) }, false) }, Field { name: "size", data_type: Int64 }, Field { name: "modificationTime", data_type: Int64 }, Field { name: "dataChange", data_type: Boolean }, Field { name: "stats", data_type: Utf8, nullable: true }, Field { name: "tags", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8, nullable: true }]) }, false), nullable: true }, Field { name: "deletionVector", data_type: Struct([Field { name: "storageType", data_type: Utf8 }, Field { name: "pathOrInlineDv", data_type: Utf8 }, Field { name: "offset", data_type: Int32, nullable: true }, Field { name: "sizeInBytes", data_type: Int32 }, Field { name: "cardinality", data_type: Int64 }]), nullable: true }, Field { name: "baseRowId", data_type: Int64, nullable: true }, Field { name: "defaultRowCommitVersion", data_type: Int64, nullable: true }, Field { name: "clusteringProvider", data_type: Utf8, nullable: true }]);N, remove:Struct([Field { name: "path", data_type: Utf8 }, Field { name: "deletionTimestamp", data_type: Int64, nullable: true }, Field { name: "dataChange", data_type: Boolean }, Field { name: "extendedFileMetadata", data_type: Boolean, nullable: true }, Field { name: "partitionValues", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8 }]) }, false), nullable: true }, Field { name: "size", data_type: Int64, nullable: true }, Field { name: "stats", data_type: Utf8, nullable: true }, Field { name: "tags", data_type: Map(Field { name: "key_value", data_type: Struct([Field { name: "key", data_type: Utf8 }, Field { name: "value", data_type: Utf8 }]) }, false), nullable: true }, Field { name: "deletionVector", data_type: Struct([Field { name: "storageType", data_type: Utf8 }, Field { name: "pathOrInlineDv", data_type: Utf8 }, Field { name: "offset", data_type: Int32, nullable: true }, Field { name: "sizeInBytes", data_type: Int32 }, Field { name: "cardinality", data_type: Int64 }]), nullable: true }, Field { name: "baseRowId", data_type: Int64, nullable: true }, Field { name: "defaultRowCommitVersion", data_type: Int64, nullable: true }]);N, __sail_delta_log_version:Int64]


physical_plan after OutputRequirements:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
    CoalescePartitionsExec
      UnionExec
        DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
          FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
            DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
              RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4
                DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
                  DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                    SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                      RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1
                        ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                          DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
        DeltaRemoveActionsExec
          RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=4
            DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=1
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet


physical_plan after aggregate_statistics:
SAME TEXT AS ABOVE

physical_plan after join_selection:
SAME TEXT AS ABOVE

physical_plan after LimitedDistinctAggregation:
SAME TEXT AS ABOVE

physical_plan after FilterPushdown:
SAME TEXT AS ABOVE

physical_plan after EnforceDistribution:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
    CoalescePartitionsExec
      UnionExec
        DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
          FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
            DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
                DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                  SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                    RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                      SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                        ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                          RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                            DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
        DeltaRemoveActionsExec
          CoalescePartitionsExec
            DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, __sail_delta_log_version@8 DESC NULLS LAST], preserve_partitioning=[true]
                      ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                          DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet


physical_plan after CombinePartialFinalAggregate:
SAME TEXT AS ABOVE

physical_plan after EnforceSorting:
OutputRequirementExec: order_by=[], dist_by=Unspecified
  DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
    CoalescePartitionsExec
      UnionExec
        DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
          FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
            DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
                DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                  SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                    RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                      ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                          DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
        DeltaRemoveActionsExec
          CoalescePartitionsExec
            DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet


physical_plan after OptimizeAggregateOrder:
SAME TEXT AS ABOVE

physical_plan after ProjectionPushdown:
SAME TEXT AS ABOVE

physical_plan after coalesce_batches:
SAME TEXT AS ABOVE

physical_plan after OutputRequirements:
DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
        FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
          DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
      DeltaRemoveActionsExec
        CoalescePartitionsExec
          DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
              SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                  ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                    RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                      DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet


physical_plan after LimitAggregation:
SAME TEXT AS ABOVE

physical_plan after LimitPushPastWindows:
SAME TEXT AS ABOVE

physical_plan after LimitPushdown:
SAME TEXT AS ABOVE

physical_plan after ProjectionPushdown:
SAME TEXT AS ABOVE

physical_plan after PushdownSort:
SAME TEXT AS ABOVE

physical_plan after EnsureCooperative:
SAME TEXT AS ABOVE

physical_plan after FilterPushdown(Post):
SAME TEXT AS ABOVE

physical_plan after RewriteExplicitRepartition:
SAME TEXT AS ABOVE

physical_plan after SanityCheckPlan:
SAME TEXT AS ABOVE

physical_plan:
DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
        FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
          DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
      DeltaRemoveActionsExec
        CoalescePartitionsExec
          DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
              SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                  ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                    RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                      DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet


== Physical Plan ==
DeltaCommitExec(table_path=file://<tmp>/delete_explain_codegen/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/delete_explain_codegen/)
        FilterExec: NOT salary@4 + 1 > 70000 AND (department@3 = Engineering OR department@3 = Marketing) AND active@5 IS NOT NULL
          DeltaScanByAddsExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
              DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
      DeltaRemoveActionsExec
        CoalescePartitionsExec
          DeltaDiscoveryExec(table_path=file://<tmp>/delete_explain_codegen/)
            DeltaLogReplayExec(table_path=file://<tmp>/delete_explain_codegen/, version=0)
              SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                  ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                    RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                      DataSourceExec: file_groups={1 group: [[<tmp>/delete_explain_codegen/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet