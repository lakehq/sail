== Parsed Logical Plan ==
MergeInto: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_cardinality_skip"], format: "DELTA", location: "<tmp>/merge_cardinality_skip", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [FunctionalDependence { source_indices: [0], target_indices: [0, 1], nullable: true, mode: Single }] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "t" }), name: "#0" }), op: Eq, right: Column(Column { relation: Some(Bare { table: "s" }), name: "#2" }) }), source: Some("t . id = s . id ") }, matched_clauses: [MergeMatchedClause { condition: None, action: UpdateSet([MergeAssignment { column: "#1", value: Column(Column { relation: Some(Bare { table: "s" }), name: "#3" }) }]) }], not_matched_by_source_clauses: [], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertAll }], join_key_pairs: [(Column(Column { relation: Some(Bare { table: "t" }), name: "#0" }), Column(Column { relation: Some(Bare { table: "s" }), name: "#2" }))], residual_predicates: [], target_only_predicates: [] }
  SubqueryAlias: t
    Projection: delta_merge_cardinality_skip.id AS #0, delta_merge_cardinality_skip.value AS #1
      TableScan: delta_merge_cardinality_skip
  SubqueryAlias: s
    Projection: src_merge_cardinality_skip.id AS #2, src_merge_cardinality_skip.value AS #3
      Projection: src_merge_cardinality_skip.#4 AS id, src_merge_cardinality_skip.#5 AS value
        SubqueryAlias: src_merge_cardinality_skip
          Projection: src.#2 AS #4, max(src.#3) AS value AS #5
            Aggregate: groupBy=[[src.#2]], aggr=[[max(src.#3)]]
              SubqueryAlias: src
                Projection: #0 AS #2, #1 AS #3
                  Projection: column1 AS #0, column2 AS #1
                    Values: (Int32(1), Utf8("s1")), (Int32(1), Utf8("s2"))

== Analyzed Logical Plan ==
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_cardinality_skip"], format: "DELTA", location: "<tmp>/merge_cardinality_skip", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [FunctionalDependence { source_indices: [0], target_indices: [0, 1], nullable: true, mode: Single }] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), source: Some("t . id = s . id ") }, matched_clauses: [MergeMatchedClause { condition: None, action: UpdateSet([MergeAssignment { column: "value", value: Column(Column { relation: None, name: "__sail_src_value" }) }]) }], not_matched_by_source_clauses: [], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertAll }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [], target_only_predicates: [] }
  Projection: CASE WHEN __common_expr_1 THEN __sail_src_id ELSE id END AS id, CASE WHEN __sail_merge_target_row_present IS NOT NULL AND __sail_merge_source_row_present IS NOT NULL THEN __sail_src_value WHEN __common_expr_1 THEN __sail_src_value ELSE value END AS value, __sail_file_path AS __sail_file_path
    Projection: __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL AS __common_expr_1, id, value, __sail_file_path, __sail_merge_target_row_present, __sail_src_id, __sail_src_value, __sail_merge_source_row_present
      Filter: __sail_merge_target_row_present IS NOT NULL OR __sail_merge_target_row_present IS NULL AND __sail_merge_source_row_present IS NOT NULL
        Full Join: id = __sail_src_id
          Projection: id, value, __sail_file_path, Boolean(true) AS __sail_merge_target_row_present
            Projection: t.#0 AS id, t.#1 AS value, t.__sail_file_path AS __sail_file_path
              SubqueryAlias: t
                Projection: delta_merge_cardinality_skip.id AS #0, delta_merge_cardinality_skip.value AS #1, delta_merge_cardinality_skip.__sail_file_path AS __sail_file_path
                  TableScan: delta_merge_cardinality_skip projection=[id, value, __sail_file_path]
          Projection: __sail_src_id, __sail_src_value, Boolean(true) AS __sail_merge_source_row_present
            Projection: s.#2 AS __sail_src_id, s.#3 AS __sail_src_value
              SubqueryAlias: s
                Projection: src_merge_cardinality_skip.id AS #2, src_merge_cardinality_skip.value AS #3
                  Projection: src_merge_cardinality_skip.#4 AS id, src_merge_cardinality_skip.#5 AS value
                    SubqueryAlias: src_merge_cardinality_skip
                      Projection: src.#2 AS #4, max(src.#3) AS value AS #5
                        Aggregate: groupBy=[[src.#2]], aggr=[[max(src.#3)]]
                          SubqueryAlias: src
                            Projection: #0 AS #2, #1 AS #3
                              Projection: column1 AS #0, column2 AS #1
                                Values: (Int32(1), Utf8("s1")), (Int32(1), Utf8("s2"))
  Projection: __sail_file_path AS __sail_file_path
    Aggregate: groupBy=[[__sail_file_path]], aggr=[[]]
      Projection: id, value, __sail_file_path, __sail_merge_target_row_present, __sail_src_id, __sail_src_value, __sail_merge_source_row_present
        Inner Join: id = __sail_src_id
          Projection: id, value, __sail_file_path, Boolean(true) AS __sail_merge_target_row_present
            Projection: t.#0 AS id, t.#1 AS value, t.__sail_file_path AS __sail_file_path
              SubqueryAlias: t
                Projection: delta_merge_cardinality_skip.id AS #0, delta_merge_cardinality_skip.value AS #1, delta_merge_cardinality_skip.__sail_file_path AS __sail_file_path
                  TableScan: delta_merge_cardinality_skip projection=[id, value, __sail_file_path], partial_filters=[Boolean(true)]
          Projection: __sail_src_id, __sail_src_value, Boolean(true) AS __sail_merge_source_row_present
            Projection: s.#2 AS __sail_src_id, s.#3 AS __sail_src_value
              SubqueryAlias: s
                Projection: src_merge_cardinality_skip.id AS #2, src_merge_cardinality_skip.value AS #3
                  Projection: src_merge_cardinality_skip.#4 AS id, src_merge_cardinality_skip.#5 AS value
                    SubqueryAlias: src_merge_cardinality_skip
                      Projection: src.#2 AS #4, max(src.#3) AS value AS #5
                        Aggregate: groupBy=[[src.#2]], aggr=[[max(src.#3)]]
                          SubqueryAlias: src
                            Projection: #0 AS #2, #1 AS #3
                              Projection: column1 AS #0, column2 AS #1
                                Values: (Int32(1), Utf8("s1")), (Int32(1), Utf8("s2"))

== Physical Plan ==
DeltaCommitExec(table_path=file://<tmp>/merge_cardinality_skip/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/merge_cardinality_skip/)
        UnionExec
          ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@5 ELSE id@1 END as id, CASE WHEN __sail_merge_target_row_present@4 IS NOT NULL AND __sail_merge_source_row_present@7 IS NOT NULL THEN __sail_src_value@6 WHEN __common_expr_1@0 THEN __sail_src_value@6 ELSE value@2 END as value]
            ProjectionExec: expr=[__sail_merge_target_row_present@3 IS NULL AND __sail_merge_source_row_present@6 IS NOT NULL as __common_expr_1, id@0 as id, value@1 as value, __sail_file_path@2 as __sail_file_path, __sail_merge_target_row_present@3 as __sail_merge_target_row_present, __sail_src_id@4 as __sail_src_id, __sail_src_value@5 as __sail_src_value, __sail_merge_source_row_present@6 as __sail_merge_source_row_present]
              FilterExec: __sail_file_path@2 IS NULL AND (__sail_merge_target_row_present@3 IS NOT NULL OR __sail_merge_target_row_present@3 IS NULL AND __sail_merge_source_row_present@6 IS NOT NULL)
                HashJoinExec: mode=CollectLeft, join_type=Full, on=[(id@0, __sail_src_id@0)]
                  DataSourceExec: file_groups={1 group: [[<tmp>/merge_cardinality_skip/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, true as __sail_merge_target_row_present], file_type=parquet
                  ProjectionExec: expr=[#2@0 as __sail_src_id, max(src.#3)@1 as __sail_src_value, true as __sail_merge_source_row_present]
                    AggregateExec: mode=FinalPartitioned, gby=[#2@0 as #2], aggr=[max(src.#3)]
                      RepartitionExec: partitioning=Hash([#2@0], 4), input_partitions=1
                        AggregateExec: mode=Partial, gby=[#2@0 as #2], aggr=[max(src.#3)]
                          ProjectionExec: expr=[column1@0 as #2, column2@1 as #3]
                            DataSourceExec: partitions=1, partition_sizes=[1]
          HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(__sail_file_path@0, __sail_file_path@2)], projection=[id@1, value@2]
            CoalescePartitionsExec
              AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                RepartitionExec: partitioning=Hash([__sail_file_path@0], 4), input_partitions=4
                  AggregateExec: mode=Partial, gby=[__sail_file_path@2 as __sail_file_path], aggr=[]
                    HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, __sail_src_id@0)]
                      DataSourceExec: file_groups={1 group: [[<tmp>/merge_cardinality_skip/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, true as __sail_merge_target_row_present], file_type=parquet, predicate=true
                      ProjectionExec: expr=[#2@0 as __sail_src_id, max(src.#3)@1 as __sail_src_value, true as __sail_merge_source_row_present]
                        AggregateExec: mode=FinalPartitioned, gby=[#2@0 as #2], aggr=[max(src.#3)]
                          RepartitionExec: partitioning=Hash([#2@0], 4), input_partitions=1
                            AggregateExec: mode=Partial, gby=[#2@0 as #2], aggr=[max(src.#3)]
                              ProjectionExec: expr=[column1@0 as #2, column2@1 as #3]
                                DataSourceExec: partitions=1, partition_sizes=[1]
            ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@5 ELSE id@1 END as id, CASE WHEN __sail_merge_target_row_present@4 IS NOT NULL AND __sail_merge_source_row_present@7 IS NOT NULL THEN __sail_src_value@6 WHEN __common_expr_1@0 THEN __sail_src_value@6 ELSE value@2 END as value, __sail_file_path@3 as __sail_file_path]
              ProjectionExec: expr=[__sail_merge_target_row_present@3 IS NULL AND __sail_merge_source_row_present@6 IS NOT NULL as __common_expr_1, id@0 as id, value@1 as value, __sail_file_path@2 as __sail_file_path, __sail_merge_target_row_present@3 as __sail_merge_target_row_present, __sail_src_id@4 as __sail_src_id, __sail_src_value@5 as __sail_src_value, __sail_merge_source_row_present@6 as __sail_merge_source_row_present]
                FilterExec: __sail_merge_target_row_present@3 IS NOT NULL OR __sail_merge_target_row_present@3 IS NULL AND __sail_merge_source_row_present@6 IS NOT NULL
                  HashJoinExec: mode=CollectLeft, join_type=Full, on=[(id@0, __sail_src_id@0)]
                    DataSourceExec: file_groups={1 group: [[<tmp>/merge_cardinality_skip/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, true as __sail_merge_target_row_present], file_type=parquet
                    ProjectionExec: expr=[#2@0 as __sail_src_id, max(src.#3)@1 as __sail_src_value, true as __sail_merge_source_row_present]
                      AggregateExec: mode=FinalPartitioned, gby=[#2@0 as #2], aggr=[max(src.#3)]
                        RepartitionExec: partitioning=Hash([#2@0], 4), input_partitions=1
                          AggregateExec: mode=Partial, gby=[#2@0 as #2], aggr=[max(src.#3)]
                            ProjectionExec: expr=[column1@0 as #2, column2@1 as #3]
                              DataSourceExec: partitions=1, partition_sizes=[1]
      DeltaRemoveActionsExec
        CoalescePartitionsExec
          DeltaDiscoveryExec(table_path=file://<tmp>/merge_cardinality_skip/)
            HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(__sail_file_path@0, __sail_file_path@0)], projection=[__sail_file_path@1, size_bytes@2, modification_time@3, _commit_version@4, _commit_timestamp@5, stats_json@6]
              CoalescePartitionsExec
                AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                  RepartitionExec: partitioning=Hash([__sail_file_path@0], 4), input_partitions=4
                    AggregateExec: mode=Partial, gby=[__sail_file_path@2 as __sail_file_path], aggr=[]
                      HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@0, __sail_src_id@0)]
                        DataSourceExec: file_groups={1 group: [[<tmp>/merge_cardinality_skip/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, true as __sail_merge_target_row_present], file_type=parquet, predicate=true
                        ProjectionExec: expr=[#2@0 as __sail_src_id, max(src.#3)@1 as __sail_src_value, true as __sail_merge_source_row_present]
                          AggregateExec: mode=FinalPartitioned, gby=[#2@0 as #2], aggr=[max(src.#3)]
                            RepartitionExec: partitioning=Hash([#2@0], 4), input_partitions=1
                              AggregateExec: mode=Partial, gby=[#2@0 as #2], aggr=[max(src.#3)]
                                ProjectionExec: expr=[column1@0 as #2, column2@1 as #3]
                                  DataSourceExec: partitions=1, partition_sizes=[1]
              DeltaLogReplayExec(table_path=file://<tmp>/merge_cardinality_skip/, version=0)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        DataSourceExec: file_groups={1 group: [[<tmp>/merge_cardinality_skip/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet