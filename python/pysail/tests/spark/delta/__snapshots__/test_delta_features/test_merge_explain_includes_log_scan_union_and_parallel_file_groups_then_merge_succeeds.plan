== Physical Plan ==
DeltaCommitExec(table_path=file://<tmp>/logscan_parallel/)
  CoalescePartitionsExec
    UnionExec
      DeltaWriterExec(table_path=file://<tmp>/logscan_parallel/)
        UnionExec
          ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@6 ELSE id@1 END as id, CASE WHEN __sail_merge_target_row_present@5 IS NOT NULL AND __sail_merge_source_row_present@8 IS NOT NULL THEN __sail_src_value@7 WHEN __common_expr_1@0 THEN __sail_src_value@7 ELSE value@2 END as value]
            ProjectionExec: expr=[__sail_merge_target_row_present@4 IS NULL AND __sail_merge_source_row_present@7 IS NOT NULL as __common_expr_1, id@0 as id, value@1 as value, __sail_file_path@2 as __sail_file_path, __sail_merge_target_row_id@3 as __sail_merge_target_row_id, __sail_merge_target_row_present@4 as __sail_merge_target_row_present, __sail_src_id@5 as __sail_src_id, __sail_src_value@6 as __sail_src_value, __sail_merge_source_row_present@7 as __sail_merge_source_row_present]
              FilterExec: __sail_file_path@2 IS NULL AND (__sail_merge_target_row_present@4 IS NOT NULL OR __sail_merge_target_row_present@4 IS NULL AND __sail_merge_source_row_present@7 IS NOT NULL)
                RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                  MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                    CoalescePartitionsExec
                      ProjectionExec: expr=[id@3 as id, value@4 as value, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_value@1 as __sail_src_value, __sail_merge_source_row_present@2 as __sail_merge_source_row_present]
                        HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)]
                          ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_value, true as __sail_merge_source_row_present]
                            DataSourceExec: partitions=1, partition_sizes=[1]
                          DataSourceExec: file_groups={3 groups: [[<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, uuid() as __sail_merge_target_row_id, true as __sail_merge_target_row_present], file_type=parquet
          HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(__sail_file_path@0, __sail_file_path@2)], projection=[id@1, value@2]
            CoalescePartitionsExec
              AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                RepartitionExec: partitioning=Hash([__sail_file_path@0], 4), input_partitions=4
                  AggregateExec: mode=Partial, gby=[__sail_file_path@2 as __sail_file_path], aggr=[]
                    FilterExec: __sail_merge_target_row_present@4 IS NOT NULL AND __sail_merge_source_row_present@7 IS NOT NULL AND id@0 = __sail_src_id@5
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                          CoalescePartitionsExec
                            ProjectionExec: expr=[id@3 as id, value@4 as value, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_value@1 as __sail_src_value, __sail_merge_source_row_present@2 as __sail_merge_source_row_present]
                              HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)]
                                ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_value, true as __sail_merge_source_row_present]
                                  DataSourceExec: partitions=1, partition_sizes=[1]
                                DataSourceExec: file_groups={3 groups: [[<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, uuid() as __sail_merge_target_row_id, true as __sail_merge_target_row_present], file_type=parquet
            ProjectionExec: expr=[CASE WHEN __common_expr_1@0 THEN __sail_src_id@6 ELSE id@1 END as id, CASE WHEN __sail_merge_target_row_present@5 IS NOT NULL AND __sail_merge_source_row_present@8 IS NOT NULL THEN __sail_src_value@7 WHEN __common_expr_1@0 THEN __sail_src_value@7 ELSE value@2 END as value, __sail_file_path@3 as __sail_file_path]
              ProjectionExec: expr=[__sail_merge_target_row_present@4 IS NULL AND __sail_merge_source_row_present@7 IS NOT NULL as __common_expr_1, id@0 as id, value@1 as value, __sail_file_path@2 as __sail_file_path, __sail_merge_target_row_id@3 as __sail_merge_target_row_id, __sail_merge_target_row_present@4 as __sail_merge_target_row_present, __sail_src_id@5 as __sail_src_id, __sail_src_value@6 as __sail_src_value, __sail_merge_source_row_present@7 as __sail_merge_source_row_present]
                FilterExec: __sail_merge_target_row_present@4 IS NOT NULL OR __sail_merge_target_row_present@4 IS NULL AND __sail_merge_source_row_present@7 IS NOT NULL
                  RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                    MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                      CoalescePartitionsExec
                        ProjectionExec: expr=[id@3 as id, value@4 as value, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_value@1 as __sail_src_value, __sail_merge_source_row_present@2 as __sail_merge_source_row_present]
                          HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)]
                            ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_value, true as __sail_merge_source_row_present]
                              DataSourceExec: partitions=1, partition_sizes=[1]
                            DataSourceExec: file_groups={3 groups: [[<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, uuid() as __sail_merge_target_row_id, true as __sail_merge_target_row_present], file_type=parquet
      DeltaRemoveActionsExec
        CoalescePartitionsExec
          DeltaDiscoveryExec(table_path=file://<tmp>/logscan_parallel/)
            HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(__sail_file_path@0, __sail_file_path@0)], projection=[__sail_file_path@1, size_bytes@2, modification_time@3, _commit_version@4, _commit_timestamp@5, stats_json@6]
              CoalescePartitionsExec
                AggregateExec: mode=FinalPartitioned, gby=[__sail_file_path@0 as __sail_file_path], aggr=[]
                  RepartitionExec: partitioning=Hash([__sail_file_path@0], 4), input_partitions=4
                    AggregateExec: mode=Partial, gby=[__sail_file_path@2 as __sail_file_path], aggr=[]
                      FilterExec: __sail_merge_target_row_present@4 IS NOT NULL AND __sail_merge_source_row_present@7 IS NOT NULL AND id@0 = __sail_src_id@5
                        RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                          MergeCardinalityCheckExec: row_id=__sail_merge_target_row_id, target_present=__sail_merge_target_row_present, source_present=__sail_merge_source_row_present
                            CoalescePartitionsExec
                              ProjectionExec: expr=[id@3 as id, value@4 as value, __sail_file_path@5 as __sail_file_path, __sail_merge_target_row_id@6 as __sail_merge_target_row_id, __sail_merge_target_row_present@7 as __sail_merge_target_row_present, __sail_src_id@0 as __sail_src_id, __sail_src_value@1 as __sail_src_value, __sail_merge_source_row_present@2 as __sail_merge_source_row_present]
                                HashJoinExec: mode=CollectLeft, join_type=Full, on=[(__sail_src_id@0, id@0)]
                                  ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_value, true as __sail_merge_source_row_present]
                                    DataSourceExec: partitions=1, partition_sizes=[1]
                                  DataSourceExec: file_groups={3 groups: [[<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet], [<tmp>/logscan_parallel/part-<id>.snappy.parquet]]}, projection=[id, value, __sail_file_path, uuid() as __sail_merge_target_row_id, true as __sail_merge_target_row_present], file_type=parquet
              DeltaLogReplayExec(table_path=file://<tmp>/logscan_parallel/, version=2)
                SortExec: expr=[__sail_delta_replay_path@6 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@6], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, stats) END as stats_json, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=3
                        UnionExec
                          DataSourceExec: file_groups={1 group: [[<tmp>/logscan_parallel/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet
                          DataSourceExec: file_groups={2 groups: [[<tmp>/logscan_parallel/_delta_log/00000000000000000001.json], [<tmp>/logscan_parallel/_delta_log/00000000000000000002.json]]}, projection=[add, remove, __sail_delta_log_version], file_type=json