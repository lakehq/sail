== Parsed Logical Plan ==
MergeInto: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_insert_only"], format: "DELTA", location: "<tmp>/merge_insert_only", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: Some(Bare { table: "t" }), name: "#0" }), op: Eq, right: Column(Column { relation: Some(Bare { table: "s" }), name: "#2" }) }), source: Some("t . id = s . id ") }, matched_clauses: [], not_matched_by_source_clauses: [], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertAll }], join_key_pairs: [(Column(Column { relation: Some(Bare { table: "t" }), name: "#0" }), Column(Column { relation: Some(Bare { table: "s" }), name: "#2" }))], residual_predicates: [], target_only_predicates: [] }
  SubqueryAlias: t
    Projection: delta_merge_insert_only.id AS #0, delta_merge_insert_only.value AS #1
      TableScan: delta_merge_insert_only
  SubqueryAlias: s
    Projection: src_merge_insert_only.id AS #2, src_merge_insert_only.value AS #3
      Projection: src_merge_insert_only.#4 AS id, src_merge_insert_only.#5 AS value
        SubqueryAlias: src_merge_insert_only
          Projection: src.#2 AS #4, src.#3 AS #5
            SubqueryAlias: src
              Projection: #0 AS #2, #1 AS #3
                Projection: column1 AS #0, column2 AS #1
                  Values: (Int32(2), Utf8("ignored")), (Int32(3), Utf8("inserted"))

== Analyzed Logical Plan ==
MergeIntoWrite: options=MergeIntoOptions { target_alias: Some("t"), source_alias: Some("s"), target: MergeTargetInfo { table_name: ["delta_merge_insert_only"], format: "DELTA", location: "<tmp>/merge_insert_only", partition_by: [], options: [[]] }, with_schema_evolution: false, resolved_target_schema: DFSchema { inner: Schema { fields: [Field { name: "#0", data_type: Int32, nullable: true }, Field { name: "#1", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "t" }), Some(Bare { table: "t" })], functional_dependencies: FunctionalDependencies { deps: [] } }, resolved_source_schema: DFSchema { inner: Schema { fields: [Field { name: "#2", data_type: Int32, nullable: true }, Field { name: "#3", data_type: Utf8, nullable: true }], metadata: {} }, field_qualifiers: [Some(Bare { table: "s" }), Some(Bare { table: "s" })], functional_dependencies: FunctionalDependencies { deps: [] } }, on_condition: ExprWithSource { expr: BinaryExpr(BinaryExpr { left: Column(Column { relation: None, name: "id" }), op: Eq, right: Column(Column { relation: None, name: "__sail_src_id" }) }), source: Some("t . id = s . id ") }, matched_clauses: [], not_matched_by_source_clauses: [], not_matched_by_target_clauses: [MergeNotMatchedByTargetClause { condition: None, action: InsertAll }], join_key_pairs: [(Column(Column { relation: None, name: "id" }), Column(Column { relation: None, name: "__sail_src_id" }))], residual_predicates: [], target_only_predicates: [] }
  Projection: __sail_src_id AS id, __sail_src_value AS value
    LeftAnti Join: __sail_src_id = id
      Projection: s.#2 AS __sail_src_id, s.#3 AS __sail_src_value
        SubqueryAlias: s
          Projection: src_merge_insert_only.id AS #2, src_merge_insert_only.value AS #3
            Projection: src_merge_insert_only.#4 AS id, src_merge_insert_only.#5 AS value
              SubqueryAlias: src_merge_insert_only
                Projection: src.#2 AS #4, src.#3 AS #5
                  SubqueryAlias: src
                    Projection: #0 AS #2, #1 AS #3
                      Projection: column1 AS #0, column2 AS #1
                        Values: (Int32(2), Utf8("ignored")), (Int32(3), Utf8("inserted"))
      Projection: t.#0 AS id, t.#1 AS value, t.__sail_file_path AS __sail_file_path
        SubqueryAlias: t
          Projection: delta_merge_insert_only.id AS #0, delta_merge_insert_only.value AS #1, delta_merge_insert_only.__sail_file_path AS __sail_file_path
            TableScan: delta_merge_insert_only projection=[id, value, __sail_file_path]
  EmptyRelation: rows=0

== Physical Plan ==
DeltaCommitExec(table_path=file://<tmp>/merge_insert_only/)
  CoalescePartitionsExec
    DeltaWriterExec(table_path=file://<tmp>/merge_insert_only/)
      ProjectionExec: expr=[__sail_src_id@0 as id, __sail_src_value@1 as value]
        HashJoinExec: mode=CollectLeft, join_type=LeftAnti, on=[(__sail_src_id@0, id@0)]
          ProjectionExec: expr=[column1@0 as __sail_src_id, column2@1 as __sail_src_value]
            DataSourceExec: partitions=1, partition_sizes=[1]
          DeltaScanByAddsExec(table_path=file://<tmp>/merge_insert_only/, version=0, projection=Some([0, 1, 2]), limit=None, pushdown=false)
            DeltaDiscoveryExec(table_path=file://<tmp>/merge_insert_only/)
              DeltaLogReplayExec(table_path=file://<tmp>/merge_insert_only/, version=0)
                SortExec: expr=[__sail_delta_replay_path@5 ASC NULLS LAST, _commit_version@3 DESC NULLS LAST], preserve_partitioning=[true]
                  RepartitionExec: partitioning=Hash([__sail_delta_replay_path@5], 4), input_partitions=4
                    ProjectionExec: expr=[CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END as __sail_file_path, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, size) END ELSE 0 END as size_bytes, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as modification_time, __sail_delta_log_version@2 as _commit_version, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, modificationTime) END ELSE 0 END as _commit_timestamp, CASE WHEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END IS NOT NULL THEN CASE WHEN add@0 IS NOT NULL THEN get_field(add@0, path) END ELSE CASE WHEN remove@1 IS NOT NULL THEN get_field(remove@1, path) END END as __sail_delta_replay_path, remove@1 IS NOT NULL as __sail_delta_is_remove, __sail_delta_log_version@2 as __sail_delta_log_version]
                      RepartitionExec: partitioning=RoundRobinBatch(4), input_partitions=1
                        DataSourceExec: file_groups={1 group: [[<tmp>/merge_insert_only/_delta_log/00000000000000000000.checkpoint.parquet]]}, projection=[add, remove, __sail_delta_log_version], file_type=parquet