{
  "tests": [
    {
      "input": {
        "query": "SELECT array_size(array('b', 'd', 'c', 'a'));",
        "result": [
          "4"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "array_size(array(b, d, c, a))",
              "nullable": false,
              "type": "integer",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "success": "ok"
      }
    },
    {
      "input": {
        "query": "SELECT cardinality(array('b', 'd', 'c', 'a'));",
        "result": [
          "4"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "cardinality(array(b, d, c, a))",
              "nullable": false,
              "type": "integer",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "success": "ok"
      }
    },
    {
      "input": {
        "query": "SELECT cardinality(map('a', 1, 'b', 2));",
        "result": [
          "2"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "cardinality(map(a, 1, b, 2))",
              "nullable": false,
              "type": "integer",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "success": "ok"
      }
    },
    {
      "input": {
        "query": "SELECT concat('Spark', 'SQL');",
        "result": [
          "SparkSQL"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "concat(Spark, SQL)",
              "nullable": false,
              "type": "string",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "success": "ok"
      }
    },
    {
      "input": {
        "query": "SELECT concat(array(1, 2, 3), array(4, 5), array(6));",
        "result": [
          "[1,2,3,4,5,6]"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "concat(array(1, 2, 3), array(4, 5), array(6))",
              "nullable": false,
              "type": {
                "type": "array",
                "elementType": "integer",
                "containsNull": false
              },
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "failure": "error in DataFusion: Error during planning: two values expected: [Alias(Alias { expr: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: MakeNullableArray { signature: Signature { type_signature: OneOf([UserDefined, Any(0)]), volatility: Immutable }, aliases: [\"make_nullable_list\"] } }, args: [Literal(Int32(1)), Literal(Int32(2)), Literal(Int32(3))] }), relation: None, name: \"array(1, 2, 3)\" }), Alias(Alias { expr: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: MakeNullableArray { signature: Signature { type_signature: OneOf([UserDefined, Any(0)]), volatility: Immutable }, aliases: [\"make_nullable_list\"] } }, args: [Literal(Int32(4)), Literal(Int32(5))] }), relation: None, name: \"array(4, 5)\" }), Alias(Alias { expr: ScalarFunction(ScalarFunction { func: ScalarUDF { inner: MakeNullableArray { signature: Signature { type_signature: OneOf([UserDefined, Any(0)]), volatility: Immutable }, aliases: [\"make_nullable_list\"] } }, args: [Literal(Int32(6))] }), relation: None, name: \"array(6)\" })]"
      }
    },
    {
      "input": {
        "query": "SELECT reverse('Spark SQL');",
        "result": [
          "LQS krapS"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "reverse(Spark SQL)",
              "nullable": false,
              "type": "string",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "failure": "error in DataFusion: Execution error: array_reverse does not support type 'Utf8'."
      }
    },
    {
      "input": {
        "query": "SELECT reverse(array(2, 1, 4, 3));",
        "result": [
          "[3,4,1,2]"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "reverse(array(2, 1, 4, 3))",
              "nullable": false,
              "type": {
                "type": "array",
                "elementType": "integer",
                "containsNull": false
              },
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "failure": "error in DataFusion: Optimizer rule 'optimize_projections' failed\ncaused by\noptimize_projections\ncaused by\nInternal error: Failed due to a difference in schemas, original schema: DFSchema { inner: Schema { fields: [Field { name: \"#0\", data_type: List(Field { name: \"element\", data_type: Int32, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }), nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }], metadata: {} }, field_qualifiers: [None], functional_dependencies: FunctionalDependencies { deps: [] } }, new schema: DFSchema { inner: Schema { fields: [Field { name: \"#0\", data_type: List(Field { name: \"item\", data_type: Int32, nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }), nullable: true, dict_id: 0, dict_is_ordered: false, metadata: {} }], metadata: {} }, field_qualifiers: [None], functional_dependencies: FunctionalDependencies { deps: [] } }.\nThis was likely caused by a bug in DataFusion's code and we would welcome that you file an bug report in our issue tracker"
      }
    },
    {
      "input": {
        "query": "SELECT size(array('b', 'd', 'c', 'a'));",
        "result": [
          "4"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "size(array(b, d, c, a))",
              "nullable": false,
              "type": "integer",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "success": "ok"
      }
    },
    {
      "input": {
        "query": "SELECT size(map('a', 1, 'b', 2));",
        "result": [
          "2"
        ],
        "schema": {
          "type": "struct",
          "fields": [
            {
              "name": "size(map(a, 1, b, 2))",
              "nullable": false,
              "type": "integer",
              "metadata": {}
            }
          ]
        }
      },
      "output": {
        "success": "ok"
      }
    }
  ]
}
