use std::collections::HashMap;

use lazy_static::lazy_static;
use regex::Regex;
use sail_spark_connect::JsonDataType;
use serde::{Deserialize, Serialize};

use crate::bootstrap::spark::common::{TestData, TestDataObject};

lazy_static! {
    static ref FUNCTION_GROUP_SUFFIX: Regex = Regex::new(r"_funcs$").unwrap();
}

#[derive(Debug, Clone, PartialEq, Deserialize)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct FunctionData {
    name: String,
    group: String,
    examples: Vec<FunctionExample>,
}

#[derive(Debug, Clone, PartialEq, Deserialize)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
pub struct FunctionExample {
    sql: String,
    result: Vec<String>,
    schema: JsonDataType,
    schema_string: String,
}

#[derive(Debug, Clone, PartialEq, Serialize)]
#[serde(rename_all = "camelCase")]
struct FunctionTestInput {
    query: String,
    result: Vec<String>,
    schema: JsonDataType,
}

#[derive(Debug, Clone, PartialEq, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct FunctionTestCase {
    input: FunctionTestInput,
}

#[derive(Debug, Clone, PartialEq, Default, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct FunctionTestSuite {
    tests: Vec<FunctionTestCase>,
}

fn clean_up_schema(schema: &mut JsonDataType) {
    match schema {
        JsonDataType::Array { element_type, .. } => {
            clean_up_schema(element_type);
        }
        JsonDataType::Map {
            key_type,
            value_type,
            ..
        } => {
            clean_up_schema(key_type);
            clean_up_schema(value_type);
        }
        JsonDataType::Struct { fields, .. } => {
            fields.iter_mut().for_each(|field| {
                clean_up_schema(&mut field.r#type);
                if let Some(metadata) = field.metadata.as_mut() {
                    metadata.remove("__autoGeneratedAlias");
                }
            });
        }
        JsonDataType::Udt { sql_type, .. } => {
            if let Some(x) = sql_type.as_mut() {
                clean_up_schema(x);
            }
        }
        _ => {}
    }
}

pub fn build_function_suites(
    data: Vec<TestData<TestDataObject<FunctionData>>>,
) -> HashMap<String, FunctionTestSuite> {
    let mut output = HashMap::new();

    data.into_iter()
        .filter(|x| x.kind == "function")
        .for_each(|x| {
            let Some(function) = x.data.into_object() else {
                return;
            };
            let group = FUNCTION_GROUP_SUFFIX
                .replace(&function.group, "")
                .to_string();
            let suite: &mut FunctionTestSuite = output.entry(group).or_default();
            function.examples.into_iter().for_each(|mut example| {
                clean_up_schema(&mut example.schema);
                suite.tests.push(FunctionTestCase {
                    input: FunctionTestInput {
                        query: example.sql,
                        result: example.result,
                        schema: example.schema,
                    },
                });
            })
        });

    output.iter_mut().for_each(|(_, suite)| {
        suite.tests.sort_by_key(|x| x.input.query.clone());
        suite.tests.dedup_by_key(|x| x.input.query.clone());
    });

    output
}
